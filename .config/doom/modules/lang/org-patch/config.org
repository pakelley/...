#+TITLE: Config
* Packages
#+begin_src elisp :tangle packages.el
(package! ob-mermaid)
(package! org-anki)
(package! org-gtd)
(package! org-ref)
(package! doct)
#+end_src

* GTD
** Keybindings
Global keybindings:
| Keybinding | Description                  |
|------------+------------------------------|
| c          | Capture (to inbox file)      |
| p          | Process inbox                |
| n          | Show all NEXT tasks          |
| s          | Show projects that are stuck |
Keybindings while processing a task:
| Keybinding | Description   |
|------------+---------------|
| C-c C-c    | Finalize task |
#+begin_src elisp
(use-package! org-gtd
  :config
  (map! (:leader (:prefix-map ("G" . "GTD")
                  :desc "Capture"             "c" #'org-gtd-capture
                  :desc "Engage"              "e" #'org-gtd-engage
                  :desc "Process Inbox"       "p" #'org-gtd-process-inbox
                  :desc "Show all next"       "n" #'org-gtd-show-all-next
                  :desc "Show stuck projects" "s" #'org-gtd-show-stuck-projects))
        ;; (:map org-gtd-command-map       "C-c C-c" #'org-gtd-clarify-finalize)
        (:map org-gtd-process-map       "C-c C-c" #'org-gtd-choose)))
#+end_src
** GTD Files
Store GTD files in XDG-based path, sync-ed by Syncthing
#+begin_src elisp
(setq org-gtd-directory "~/.local/share/notes/gtd/")
#+end_src
** Other Recommended config
These are suggested by the `org-gtd` README: set tags when processing tasks, add a `DELEGATED_TO` property, and add an agenda keybinding to the agenda
#+begin_src elisp
(setq org-gtd-process-item-hooks '(org-set-tags-command))
#+end_src
** `org-edna` config for GTD
Right now this is only the recommendations from `org-gtd`, but I'll probably add more eventually.
#+begin_src elisp
(setq org-edna-use-inheritance t)
(org-edna-mode 1)
#+end_src
* Roam
** Roam Files
Store `org-roam` files in XDG-based path, sync-ed by Syncthing
#+begin_src elisp
(setq org-roam-directory "~/.local/share/notes/org-roam/")
#+end_src
** Roam completion everywhere
On the fence about this one, need to check on the performance. Makes linking roam notes together simple though, so I'm enabling it for now: it just provides tab completion for roam note titles.
#+begin_src elisp
(setq org-roam-completion-everywhere t)
#+end_src
** Capture templates [0/1]
- [ ] TODO review these
Still a WIP, currently working off of the (fantastic) system crafters examples
It takes some work to get `doct` to work with org roam... but from [[https://gist.github.com/vherrmann/f9b21eeea7d7c9123dc400a30599d50d][this gist]], we get the `doct-org-roam` function:
#+begin_src elisp
(defun doct-org-roam-convert (groups)
  "Convert GROUPS of templates to `org-roam' compatible templates."
  (setq doct-templates
        (mapcar (lambda (template)
                  (if-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                            (org-roam-props (plist-get (plist-get props :doct) :org-roam)))
                      `(,@template ,@org-roam-props)
                    template))
                (doct-flatten-lists-in groups))))

(defun doct-org-roam--target-file (value)
  "Convert declaration's :file VALUE and extensions to capture template syntax."
  (let (type target)
    ;; TODO: This doesn't catch :olp used together with :datetree
    (when-let ((olp (doct--get :olp)))
      (push :olp type)
      (push olp target))
    (if-let ((head (doct--get :head)))
        (progn
          (push :head type)
          (push (pcase head
                  ((pred stringp) (if (doct--expansion-syntax-p head)
                                      (doct--replace-template-strings
                                       head)
                                    head))
                  ((pred functionp) (doct--fill-template (funcall head)))
                  ((pred doct--list-of-strings-p)
                   (mapconcat (lambda (element)
                                (if (doct--expansion-syntax-p element)
                                    (doct--fill-template element)
                                  element))
                              head "\n")))
           target))
      (when-let ((datetree (doct--get :datetree)))
        (push :datetree type)
        (push datetree target)))
    (push :file type)
    (push (doct--type-check :file value '(stringp doct--variable-p)) target)
    `(,(intern (mapconcat (lambda (keyword)
                            (substring (symbol-name keyword) 1))
                          (delq nil type) "+"))
      ,@(delq nil target))))

(defun doct-org-roam--target ()
  "Convert declaration's target to template target."
  (let ((doct-exclusive-target-keywords '(:file :node)))
    (pcase (doct--first-in doct-exclusive-target-keywords)
      ('nil (signal 'doct-no-target `(,doct-exclusive-target-keywords nil ,doct--current)))
      (`(:id ,id) `(id ,(doct--type-check :id id '(stringp))))
      (`(:file ,file) (doct-org-roam--target-file file)))))

(defun doct-org-roam--compose-entry (keys name parent)
  "Return a template suitable for `org-roam-capture-templates'.
The list is of the form: (KEYS NAME type target template additional-options...).
`doct--current-plist' provides the type, target template and additional options.
If PARENT is non-nil, list is of the form (KEYS NAME)."
  `(,keys ,name
          ,@(unless parent
              `(,(doct--entry-type)
                ,(doct--template)
                :target ,(doct-org-roam--target)
                ,@(doct--additional-options)))
          :doct ( :doct-name ,name
                  ,@(cdr doct--current)
                  ,@(when-let ((custom (doct--custom-properties)))
                      `(:doct-custom ,custom)))))

(defun doct-org-roam (declarations)
  "Convert DECLARATIONS to `org-roam-capture-templates'.
DECLARATIONS must be of the same form that `doct' expects with
one addition: the :org-roam keyword.
The :org-roam keyword's value must be a plist mapping `org-roam''s
template syntax extensions (e.g. :file-name :head) to their appropriate values.
Note this does validate the :org-roam plist's values or keywords."

;;TODO: we should preserve doct-after-conversion-functions
;;in case user already has other functions set.
(let ((doct-after-conversion-functions (append '(doct-org-roam-convert)
                                               doct-after-conversion-functions)))
  (cl-letf (((symbol-function 'doct--compose-entry) #'doct-org-roam--compose-entry))
      (doct declarations))))
#+end_src
#+begin_src elisp
(setq org-roam-completion-system 'default
      org-roam-capture-templates
      (doct-org-roam
       '(:group "Org Roam"
         :file "%<%Y%m%d%H%M%S>-${slug}.org.gpg"
         :head "#+title: ${title}\n"
         :unnarrowed t
         :function ignore ;org-roam hardcodes target file logic
         :type plain
         :children
         (("Default"
           :keys "d"
           :template "%?")
          ("Anki Card"
           :keys "a"
           :hook ,(defun set-anki-deck-from-tags ()
                    (let ((tags (completing-read-multiple "Tag: " (org-roam-tag-completions))))
                      (org-roam-tag-add tags)
                      ; NOTE this only sets the first tag as ANKI_DECK
                      (org-set-property "ANKI_DECK" (car tags))))
           :template ("* ${title}"
                      "%?"))))))

(setq org-roam-dailies-directory "dailies/"
      org-roam-dailies-capture-templates
       '(("d" "default" entry
          #'org-roam-capture--get-point
          "* %?"
          :file-name "Journal/%<%Y-%m-%d>"
          :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
         ("t" "Task" entry
          #'org-roam-capture--get-point
          "* TODO %?\n  %U\n  %a\n  %i"
          :file-name "Journal/%<%Y-%m-%d>"
          :olp ("Tasks")
          :empty-lines 1
          :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
         ("j" "journal" entry
          #'org-roam-capture--get-point
          "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
          :file-name "Journal/%<%Y-%m-%d>"
          :olp ("Log")
          :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
         ("l" "log entry" entry
          #'org-roam-capture--get-point
          "* %<%I:%M %p> - %?"
          :file-name "Journal/%<%Y-%m-%d>"
          :olp ("Log")
          :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
         ("m" "meeting" entry
          #'org-roam-capture--get-point
          "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
          :file-name "Journal/%<%Y-%m-%d>"
          :olp ("Log")
       :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")))
#+end_src
* Reference [0/1]
- [ ] TODO change these to relative paths
- [ ] TODO set up ebib (the [[a][spacemacs bibtex layer]] should be helpful)
Use org-ref and bibtex for bibliographic references
#+begin_src elisp
(use-package! org-ref
  :config
  (setq bibtex-completion-bibliography "/Users/pakelley/.local/share/bibtex/references.bib"
        bibtex-completion-library-path "/Users/pakelley/.local/share/bibtex/pdfs/"
        bibtex-completion-notes-path "/Users/pakelley/.local/share/bibtex/notes.org")
  (setq reftex-default-bibliography '("/Users/pakelley/.local/share/bibtex/references.bib"))
  (setq org-ref-default-bibliography '("/Users/pakelley/.local/share/bibtex/references.bib")
        org-ref-pdf-directory "/Users/pakelley/.local/share/bibtex/pdfs/"
        org-ref-bibliography-notes "/Users/pakelley/.local/share/bibtex/notes.org"))
#+end_src
* Todos
** Todo keywords [0/1]
- [ ] TODO: do I need both `CANCELLED` and `TRASH`?
The sequence of stages my tasks go through. See the [[https://orgmode.org/manual/Tracking-TODO-state-changes.html][org manual]] for more info, but `!` gives a timestamp, `@` lets you leave a note when transitioning through that state, and `/` denotes whether the other symbols happen when transitioning in vs out of the state (before `/` is for transitioning into the state, which is the default).
- TODO: on the agenda, but not something to immediately work on
- NEXT: something I can immediately pick up
- WAIT: blocked by something, don't even consider it a todo until it's unblocked
- DONE: finished, congrats
- CANCELLED: decided not to do this while working on it
- TRASH: decided not to do this while prioritizing
#+begin_src elisp
(setq org-todo-keywords
      '((sequence "NEXT(n)" "TODO(t!)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@!)" "TRASH(r!)")))
(setq org-todo-keyword-faces
      '(("NEXT" . (:foreground "#f0dfaf" :weight bold))
        ("WAIT" . (:foreground "#dc8cc3" :weight bold))
        ("CANCELED" . (:foreground "#8cd0d3" :weight bold))
        ("TRASH" . (:foreground "#dfaf8f" :weight bold))))
#+end_src
* Capture
** Quick keybinding
#+begin_src elisp
(define-key global-map "\C-cc" 'org-capture)
#+end_src
** Capture Templates [0/1]
- [ ] TODO: revisit these
#+begin_src elisp
(setq org-capture-templates
      '(("b" "Bombora" entry (file+datetree "~/SparkleShare/org/work/bombora/bombora.cap.org")
         "* %?\n  %i\n  %a")
        ("B" "Bombora Retro" entry (file+datetree "~/SparkleShare/org/work/bombora/bombora.retro.org")
         "* %?\n  %i\n  %a")
        ("i" "Inbox"
         entry (file "~/.local/share/notes/gtd/inbox.org")
         "* %?\n%U\n\n  %i"
         :kill-buffer t)
        ("l" "Todo with link"
         entry (file "~/.local/share/notes/gtd/inbox.org")
         "* %?\n%U\n\n  %i\n  %a"
         :kill-buffer t)))
#+end_src
* Agenda
** Always include clockreport mode
This gives some useful summary info about time spent on tasks from the agenda, when you have the discipline to use org's clock features.
#+begin_src elisp
(setq org-agenda-start-with-clockreport-mode t)
#+end_src
** Clockreport format [0/1]
- [ ] TODO revisit this (I think I have it set up for org-pomodoro, but can't remember anymore)
#+begin_src elisp
(setq org-agenda-clockreport-parameter-plist
      '(:link t :maxlevel 2 :formula "$5=$3+$4;t::$6=ceil($5*60/25);N"))
#+end_src
* Deft
#+begin_src elisp
(setq deft-directory "~/.local/share/notes")
(setq deft-recursive t)
#+end_src
* General
** Notes directory
Top-level note directory, synced with Syncthing
#+begin_src elisp
(setq org-directory "~/.local/share/notes")
#+end_src
** Render latex fragments when opening org file
#+begin_src elisp
(setq org-startup-with-latex-preview t)
#+end_src
** Word wrap
Commenting this out for now; doom seems to do a good job of this on its own
#+begin_src elisp
;(setq org-startup-truncated nil)
;(setq org-startup-indented t)
#+end_src
** Refile
Commenting this out for now, unless I decide I need it
#+begin_src elisp
;(setq org-refile-targets
;      '((nil :maxlevel . 3)
;        (org-agenda-files :maxlevel . 3)))
#+end_src
* Babel [0/1]
- [ ] TODO revisit these
** Confirm evaluate
Don't prompt me to confirm every time I want to evaluate a block
#+begin_src elisp
(setq org-confirm-babel-evaluate nil)
#+end_src
** Inline images
Display/udate images in the buffer after I evaluate a block
#+begin_src elisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src
** Mermaid
Use [[https://mermaid-js.github.io/mermaid/#/][mermaid.js]] to generate diagrams in org files (rendered by babel)
Notably, you'll need to install [[https://github.com/mermaid-js/mermaid-cli][mermaid-cli]].
#+begin_src elisp
(use-package! ob-mermaid
  :config
  (setq ob-mermaid-cli-path "/usr/local/bin/mmdc"))
#+end_src
* Pomodoro [0/1]
- [ ] TODO review this
#+begin_src elisp
(setq org-pomodoro-length 40)
(setq org-pomodoro-short-break-length 10)
(setq org-pomodoro-long-break-length 20)
(setq org-pomodoro-play-sounds 0)
;(setq alert-default-style 'growl)
#+end_src
* Tags [0/1]
- [ ] TODO figure out a better way of updating this
#+begin_src elisp
(setq org-tag-alist
      '(
        ("Configuration")
        ; GTD
        (:startgrouptag)
        ("GTD")
        (:grouptags)
        ("Control")
        ("Persp")
        (:endgrouptag)
        (:startgrouptag)
        ("Control")
        (:grouptags)
        ("Context")
        ("Task")
        (:endgrouptag)
        ("Circuit Theory")))
#+end_src
