#+TITLE: Config
#+property: header-args:emacs-lisp :tangle yes
#+property: header-args:elisp :tangle yes

* Packages
#+begin_src elisp :tangle packages.el
(package! deft)
(package! noflet)
(package! ob-mermaid)
(package! org-anki)
(package! org-gtd)
(package! org-ref)
(package! org-pomodoro)
(package! doct)
(package! org-super-agenda :pin "fb5e2ef277bc811a3b061106c99e4c47b6b86f80")
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "87772a9469d91770f87bfa788580fca69b9e697a")


(package! org-modern)
(package! org-ql)
(package! origami)
(package! ox-pandoc)
(package! poly-org)
#+end_src

* GTD
** Keybindings
Global keybindings:
| Keybinding | Description                    |
|------------+--------------------------------|
| a          | archive (to sibling "Archive") |
| V          | Show all org-ql views          |
| DEL        | Process item in the inbox      |
| r c        | Convert to project             |
| r n        | Create new project             |
Keybindings while creating a project:
| Keybinding | Description                      |
|------------+----------------------------------|
| C-c C-c    | Finish modifying project (widen) |

#+name: gtd-projects
#+begin_src emacs-lisp :tangle no
(defvar +patch/refine-project-map (make-sparse-keymap)
  "Keymap for command `+patch/refine-project-mode', a minor mode.")

(define-minor-mode +patch/refine-project-mode
  "Minor mode for org-gtd."
  nil " +prp" +patch/refine-project-map
  :global nil
  (if +patch/refine-project-mode
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<+patch/refine-project-mode>Refine project, add subtasks, then press `C-c C-c' to complete."))
    (setq-local header-line-format nil)))

(defun +patch/convert-to-project ()
    (interactive)
    (org-tree-to-indirect-buffer)
    (+patch/refine-project-mode t))

(defun +patch/create-new-project ()
    (interactive)
    (let* ((org-refile-targets `((,+patch/org-gtd-tasks-file :regexp . "*")))
           (rfloc (org-refile-get-location "Parent location for new project")))
      (org-refile t nil rfloc)
      (+org/insert-item-below 1)
      (org-cycle)
      (org-tree-to-indirect-buffer)
      (+patch/refine-project-mode t)))

(defun +patch/refile-to-project ()
    (interactive)
    (let* ((org-refile-targets `((,+patch/org-gtd-tasks-file :regexp . "*")))
           (rfloc (org-refile-get-location "Project to move this task into")))
      (org-refile nil nil rfloc)))

(setq +patch--widen-hooks '())

(defun +patch/widen ()
  (interactive)
  (widen)
  (+patch/refine-project-mode -1)
  (dolist (hook +patch--widen-hooks)
    (save-excursion
      (save-restriction
        (funcall hook)))))
#+end_src
#+begin_src elisp :noweb no-export
(use-package! org-gtd
  :after (org org-ql)
  ;; TODO this isn't being set properly using :custom, need to debug why when I have a chance
  ;;:custom
  ;;(+patch/org-gtd-tasks-file (concat (file-name-as-directory org-gtd-directory) "org-gtd-tasks.org"))
  :init
  <<org-gtd-directory>>
  <<org-gtd-recommendations>>
  <<org-gtd-edna>>
  <<agenda-incubate-and-hatch>>
  <<gtd-projects>>
  (map! (:map evil-normal-state-map
              (:prefix-map ("DEL" . "GTD")
               :desc "Archive"             "a" #'org-archive-to-archive-sibling
               :desc "Views"               "V" #'org-ql-view
               :desc "Process Item"        "DEL" #'+patch-gtd/process-inbox-item
               (:prefix ("r" . "Projects")
                :desc "Convert to project" "c" #'+patch/convert-to-project
                :desc "Create new project" "n" #'+patch/create-new-project)))
        (:map +patch/refine-project-map       "C-c C-c" #'+patch/widen)))

#+end_src
** GTD Files
Store GTD files in XDG-based path, sync-ed by Syncthing
#+name: org-gtd-directory
#+begin_src elisp :tangle no
(setq org-gtd-directory "~/.local/share/notes/gtd/")
#+end_src
** Other Recommended config
These are suggested by the `org-gtd` README: set tags when processing tasks, add a `DELEGATED_TO` property, and add an agenda keybinding to the agenda
#+name: org-gtd-recommendations
#+begin_src elisp :tangle no
(setq org-gtd-process-item-hooks '(org-set-tags-command))
#+end_src
** `org-edna` config for GTD
Right now this is only the recommendations from `org-gtd`, but I'll probably add more eventually.
#+name: org-gtd-edna
#+begin_src elisp :tangle no
(setq org-edna-use-inheritance t)
(org-edna-mode 1)
#+end_src
Notably, I use the following property for edna to keep tasks from marking DONE tasks as NEXT:
:TRIGGER: if next-sibling match("/+DONE") then else next-sibling todo!(NEXT) endif
I tried to get !done? to work here, but it seemed to work the opposite of how I'd expect.
* Roam
#+begin_src elisp :noweb no-export
(use-package! org-roam
  :after doct
  :custom
  <<org-roam-directory>>
  <<org-roam-completion-everywhere>>
  :config
  <<doct-org-roam>>
  <<org-roam-capture-templates>>
  ;; start org-roam on startup
  (org-roam-db-autosync-mode))
#+end_src
** Roam Files
Store `org-roam` files in XDG-based path, sync-ed by Syncthing
#+name: org-roam-directory
#+begin_src elisp :tangle no
(org-roam-directory "~/.local/share/notes/zettelkasten/")
#+end_src
** Roam completion everywhere
On the fence about this one, need to check on the performance. Makes linking roam notes together simple though, so I'm enabling it for now: it just provides tab completion for roam note titles.
#+name: org-roam-completion-everywhere
#+begin_src elisp :tangle no
(org-roam-completion-everywhere t)
#+end_src
** Capture templates
It takes some work to get `doct` to work with org roam... but from [[https://gist.github.com/vherrmann/f9b21eeea7d7c9123dc400a30599d50d][this gist]], we get the `doct-org-roam` function:
#+name: doct-org-roam
#+begin_src elisp :tangle no
(defun doct-org-roam-convert (groups)
  "Convert GROUPS of templates to `org-roam' compatible templates."
  (setq doct-templates
        (mapcar (lambda (template)
                  (if-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                            (org-roam-props (plist-get (plist-get props :doct) :org-roam)))
                      `(,@template ,@org-roam-props)
                    template))
                (doct-flatten-lists-in groups))))

(defun doct-org-roam--target-file (value)
  "Convert declaration's :file VALUE and extensions to capture template syntax."
  (let (type target)
    ;; TODO: This doesn't catch :olp used together with :datetree
    (when-let ((olp (doct--get :olp)))
      (push :olp type)
      (push olp target))
    (if-let ((head (doct--get :head)))
        (progn
          (push :head type)
          (push (pcase head
                  ((pred stringp) (if (doct--expansion-syntax-p head)
                                      (doct--replace-template-strings
                                       head)
                                    head))
                  ((pred functionp) (doct--fill-template (funcall head)))
                  ((pred doct--list-of-strings-p)
                   (mapconcat (lambda (element)
                                (if (doct--expansion-syntax-p element)
                                    (doct--fill-template element)
                                  element))
                              head "\n")))
                target))
      (when-let ((datetree (doct--get :datetree)))
        (push :datetree type)
        (push datetree target)))
    (push :file type)
    (push (doct--type-check :file value '(stringp doct--variable-p)) target)
    `(,(intern (mapconcat (lambda (keyword)
                            (substring (symbol-name keyword) 1))
                          (delq nil type) "+"))
      ,@(delq nil target))))

(defun doct-org-roam--target ()
  "Convert declaration's target to template target."
  (let ((doct-exclusive-target-keywords '(:file :node)))
    (pcase (doct--first-in doct-exclusive-target-keywords)
      ('nil (signal 'doct-no-target `(,doct-exclusive-target-keywords nil ,doct--current)))
      (`(:id ,id) `(id ,(doct--type-check :id id '(stringp))))
      (`(:file ,file) (doct-org-roam--target-file file)))))

(defun doct-org-roam--compose-entry (keys name parent)
  "Return a template suitable for `org-roam-capture-templates'.
The list is of the form: (KEYS NAME type target template additional-options...).
`doct--current-plist' provides the type, target template and additional options.
If PARENT is non-nil, list is of the form (KEYS NAME)."
  `(,keys ,name
          ,@(unless parent
              `(,(doct--entry-type)
                ,(doct--template)
                :target ,(doct-org-roam--target)
                ,@(doct--additional-options)))
          :doct ( :doct-name ,name
                  ,@(cdr doct--current)
                  ,@(when-let ((custom (doct--custom-properties)))
                      `(:doct-custom ,custom)))))

(defun doct-org-roam (declarations)
  "Convert DECLARATIONS to `org-roam-capture-templates'.
DECLARATIONS must be of the same form that `doct' expects with
one addition: the :org-roam keyword.
The :org-roam keyword's value must be a plist mapping `org-roam''s
template syntax extensions (e.g. :file-name :head) to their appropriate values.
Note this does validate the :org-roam plist's values or keywords."

  ;;TODO: we should preserve doct-after-conversion-functions
  ;;in case user already has other functions set.
  (let ((doct-after-conversion-functions (append '(doct-org-roam-convert)
                                                 doct-after-conversion-functions)))
    (cl-letf (((symbol-function 'doct--compose-entry) #'doct-org-roam--compose-entry))
      (doct declarations))))
#+end_src
Notably, the backtick is crucial for setting the hook in my anki template
#+name: org-roam-capture-templates
#+begin_src elisp :tangle no
(setq org-roam-completion-system 'default
      org-roam-capture-templates
      (doct-org-roam
       `(:group "Org Roam"
         :file "%<%Y%m%d%H%M%S>-${slug}.org"
         :head "#+title: ${title}\n"
         :unnarrowed t
         :function ignore ;org-roam hardcodes target file logic
         :type plain
         :children
         (("Default"
           :keys "d"
           :template "%?")
          ("Anki Card"
           :keys "a"
           :hook ,(defun set-anki-deck-from-tags ()
                    (let ((tags (completing-read-multiple "Tag: " (org-roam-tag-completions))))
                      (org-roam-tag-add tags)
                                        ; NOTE this only sets the first tag as ANKI_DECK
                      (org-set-property "ANKI_DECK" (car tags))))
           :template ("* ${title}"
                      "%?"))))))

(setq org-roam-dailies-directory "journals/"
      org-roam-dailies-capture-templates
      '(("d" "default" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "Journal/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("t" "Task" entry
         #'org-roam-capture--get-point
         "* TODO %?\n  %U\n  %a\n  %i"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Tasks")
         :empty-lines 1
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("j" "journal" entry
         #'org-roam-capture--get-point
         "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Log")
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("l" "log entry" entry
         #'org-roam-capture--get-point
         "* %<%I:%M %p> - %?"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Log")
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("m" "meeting" entry
         #'org-roam-capture--get-point
         "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Log")
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")))
#+end_src
** Dailies Protocol
#+begin_src emacs-lisp
(after! org-protocol
  (defun org-roam-protocol-open-daily (info)
    (let ((goto (plist-get info :goto))
          (keys (plist-get info :keys)))
      (org-roam-dailies-capture-today goto keys))
    nil)

  (push '("org-roam-daily"  :protocol "roam-daily"   :function org-roam-protocol-open-daily)
        org-protocol-protocol-alist))
#+end_src
* Reference [0/1]
- [ ] TODO change these to relative paths
- [ ] TODO set up ebib (the [[a][spacemacs bibtex layer]] should be helpful)
Use org-ref and bibtex for bibliographic references
#+begin_src elisp
(use-package! org-ref
  :defer t
  :config
  (setq bibtex-completion-bibliography "/Users/pakelley/.local/share/bibtex/references.bib"
        bibtex-completion-library-path "/Users/pakelley/.local/share/bibtex/pdfs/"
        bibtex-completion-notes-path "/Users/pakelley/.local/share/bibtex/notes.org")
  (setq reftex-default-bibliography '("/Users/pakelley/.local/share/bibtex/references.bib"))
  (setq org-ref-default-bibliography '("/Users/pakelley/.local/share/bibtex/references.bib")
        org-ref-pdf-directory "/Users/pakelley/.local/share/bibtex/pdfs/"
        org-ref-bibliography-notes "/Users/pakelley/.local/share/bibtex/notes.org"))
#+end_src
* Todos
** Todo keywords [0/1]
- [ ] TODO: do I need both `CANCELLED` and `TRASH`?
The sequence of stages my tasks go through. See the [[https://orgmode.org/manual/Tracking-TODO-state-changes.html][tracking TODO state changes]] and [[https://orgmode.org/manual/Fast-access-to-TODO-states.html][fast access to TODO states]] for more info, but `!` gives a timestamp, `@` lets you leave a note when transitioning through that state, and `/` denotes whether the other symbols happen when transitioning in vs out of the state (before `/` is for transitioning into the state, which is the default).
- INCUBATE: Task that needs more refinement before being considered to work on (refinement typically done during quarterly review)
- READY: Task that is well-defined, but not selected to work on (typically, more tasks are selected each quarter). Notably, I log when tasks leave this state because this is when they've been planned to be worked on. I also set an OPENED property when this gets logged.
- TODO: selected to work on, but maybe not something to immediately work on (prefer NEXT actions to TODO actions)
- NEXT: the next action in a project (in the GTD sense)
- WAIT: blocked by something, don't consider it a todo until it's unblocked
- DONE: finished, congrats
- CNCL: "cancelled", decided not to do this task

#+name: todo-keywords
#+begin_src elisp :tangle no
(setq org-todo-keywords
      '((sequence "INCUBATE(i)" "READY(r/!)" "TODO(t)" "NEXT(n)" "WAIT(w@!/!)" "|" "DONE(d!)" "CNCL(c@!)")))
(setq org-todo-keyword-faces
      '(("INCUBATE" . (:foreground "#dfaf8f" :weight bold))
        ("READY" . (:foreground "#8cd0d3" :weight bold))
        ("NEXT" . (:foreground "#f0dfaf" :weight bold))
        ("WAIT" . (:foreground "#dc8cc3" :weight bold))
        ("CNCL" . (:foreground "#d26478" :weight bold))))
#+end_src

Use org modern to make todos look nice.
#+name: org-modern-todo-faces
#+begin_src emacs-lisp :tangle no
(org-modern-todo-faces
      '(("INCUBATE" . (:background "#dfaf8f" :foreground "black" :weight semibold))
        ("READY"    . (:background "#8cd0d3" :foreground "black" :weight semibold))
        ("NEXT"     . (:background "#f0dfaf" :foreground "black" :weight semibold))
        ("WAIT"     . (:background "#dc8cc3" :foreground "black" :weight semibold))
        ("CNCL"     . (:background "#d26478" :foreground "black" :weight semibold))))
#+end_src
** Getters/Setters
We'll want to be able to interact with the opened date (i.e. the date a task was moved from READY to TODO/NEXT) and TO-PLAN status (used during yearly planning) from org-ql, so let's make some functions for the main tasks we'll want: viewing the opened date (e.g. `:select` in `org-ql-query`), and predicate/fitering (e.g. `where` in `org-ql-query`).
Viewing funtions for "opened":
#+name: view-planning-props-orgql
#+begin_src emacs-lisp :tangle no
(defun +patch--get-path (task)
  "Try to find the path to TASK by walking up ':parent' tasks (found using the
org element API), then getting the ':path' property of the top."
  (when task
    (or (org-element-property :path task)
        (+patch--get-path (org-element-property :parent task)))))

(defmacro +patch--from-task-location (task &rest body)
  "Runs BODY from the buffer of the task specified by 'task'. This will try to
find the buffer via the ':org-marker' property in the org element api, or by
walking up ':parent' tasks until the top, and getting the ':path' property and
getting a buffer (opening if necessary) for that file"
   `(let ((buffer (if-let ((marker (org-element-property :org-marker ,task)))
                     (marker-buffer marker)
                   (find-file-noselect (+patch--get-path task)))))
     (with-current-buffer buffer
       ,@body)))

(defun +patch--get-contents (task)
  "Using the org element API, get the contents of a task (i.e. the plain text
after the headline).

If there's a marker, use that (because it's more robust), otherwise recursively
search up the task tree for a ':path' property (and hope for the best)."
  (+patch--from-task-location task
    (let* ((beg (org-element-property :contents-begin task))
           (end (org-element-property :contents-end task)))
      (when beg (when end (buffer-substring-no-properties beg end))))))

(defconst +patch/org-ql-opened-regexp
  (rx bol ":OPENED:   " (group (1+ not-newline))))

(defun +patch/get-opened-date (task)
  "Get the date a task was opened (i.e. moved from READY to TODO/NEXT) using
the org element api. Requires fetching the content of the task (which I don't
have a reliable process for yet)."
  (let* ((opened-prop (org-element-property :OPENED task)))
    (when opened-prop
      (let* ((opened-ts (ts-parse opened-prop))
             (opened-date (ts-format "%Y-%m-%d" opened-ts)))
        opened-date))))

(defun +patch/set-opened-date (&optional pom date)
  "Set the OPENED date of a task."
  (interactive)
  (let* ((pom (or pom (point)))
         (date (or date (org-read-date)))
         (date-str (ts-format "%Y-%m-%d" (ts-parse date))))
    (org-entry-put pom "OPENED" date-str)))

(defun +patch/agenda-set-opened-date (arg &optional date)
  "Set the OPENED date of a task from the org agenda."
  (interactive "P")
  (+patch/set-opened-date (org-get-at-bol 'org-marker) date))

(defun +patch/reopen-task (&optional pom date)
  "Change the OPENED date of a task, and unchedule any scheduled time."
  (org-agenda-schedule '(4))  ;; prefix arg to unschedule
  (+patch/set-opened-date pom date))

(defun +patch/agenda-reopen-task (arg &optional date)
  "Change the OPENED date of a task, and unchedule any scheduled time, from the
org agenda."
  (interactive "P")
  (+patch/reopen-task (org-get-at-bol 'org-marker) date))

(defun +patch/mark-task-for-planning (&optional pom)
  "Mark a task (at 'pom' or 'point') to be planned in yearly planning (i.e. set
the 'TO-PLAN' property)."
  (org-entry-put (or pom (point)) "TO-PLAN" ""))

(defun +patch/mark-task-as-planned (&optional pom)
  "Mark a task (at 'pom' or 'point') as planned in yearly planning (i.e. unset
the 'TO-PLAN' property)."
  (interactive)
  (org-entry-delete (or pom (point)) "TO-PLAN"))

(defun +patch/open-task-after-state-change ()
  "Open a task (by setting the 'OPENED' and 'TO-PLAN' properties). Meant to be
used in the 'org-after-todo-state-change-hook'."
  (when (equal org-last-state "READY")
    (+patch/set-opened-date (point)
                            (format-time-string
                             "%Y-%m-%d"
                             org-log-note-effective-time))
    (+patch/mark-task-for-planning)))
(add-hook 'org-after-todo-state-change-hook '+patch/open-task-after-state-change)
    #+end_src

Predicate functions:
#+name: planning-predicates-orgql
#+begin_src emacs-lisp :tangle no
(org-ql-defpred opened (&key from to _on)
  "Return non-nil if current entry contains READY state change in given period."
  :normalizers ((`(,predicate-names ,(and num-days (pred numberp)))
                 ;; (clocked) and (closed) implicitly look into the past.
                 (let* ((from-day (* -1 num-days))
                        (rest (list :from from-day)))
                   (org-ql--normalize-from-to-on
                     `(opened :from ,from))))
                (`(,predicate-names . ,rest)
                 (org-ql--normalize-from-to-on
                   `(opened :from ,from :to ,to))))
  :preambles
  ((`(,predicate-names . ,rest)
    (list
     ;; Predicate needs testing only when args are present.
     :query (-let (((&keys :from :to :on) rest))
              ;; TODO: This used to be (when (or from to on) query), but
              ;; that doesn't seem right, so I changed it to this if, and the
              ;; tests pass either way.  Might deserve a little scrutiny.
              (if (or from to on)
                  query
                t)))))
  :body
    (when-let ((opened-prop (org-entry-get (point) "OPENED")))
      (let ((opened-at (ts-parse opened-prop)))
        (save-excursion
          (cond ((not (or from to)) opened-at)
                ((and from to) (ts-in from to opened-at))
                (from (ts<= from opened-at))
                (to (ts<= opened-at to))))))
  )

(org-ql-defpred to-plan (&rest names)
  "Check whether a task needs to be planned (i.e. has a 'TO-PLAN' property)."
  :body (property "TO-PLAN"))
#+end_src

Because all of my TODO/NEXT tasks will have at least one thing logged (because I log when tasks go from READY to TODO/NEXT), log state changes into the logbook to keep task contents tidy.
#+name: state-changes-in-logbook
#+begin_src emacs-lisp :tangle no
(setq org-log-into-drawer t)
#+end_src

* Capture
** Capture Templates [0/1]
`doct` makes writing capture templates much simpler and more readable
#+begin_src elisp :noweb no-export
(use-package! doct
  :after (org org-capture)
  :commands (doct +patch/doct-properties)
  :defines +patch/doct-properties
  :config
  <<doct-properties-hook>>
  <<org-capture-templates>>
  :config
  <<doct-properties-hook>>
  )

#+end_src
Nice function for passing properties to `doct` modified from [[https://github.com/progfolio/doct/issues/13][this GH issue]].
#+name: doct-properties-hook
#+begin_src elisp :tangle no
(defun +patch/doct-properties ()
  "Add declaration's :properties to current entry."
  (let ((properties (doct-get :properties)))
    (dolist (keyword (seq-filter #'keywordp properties))
      (let* ((property (substring (symbol-name keyword) 1))
             (raw-value (plist-get properties keyword))
             (expanded-value (if (string-match-p ".*%(.*" raw-value)
                        (org-capture-fill-template raw-value)
                      raw-value))
             (clean-value (replace-regexp-in-string "\n$" "" expanded-value)))
        (org-set-property property clean-value)))))
;; Usage:
;; (doct '(("My capture template"
;;          ...
;;          :hook +patch/org-property-drawer
;;          :properties (:anki_deck "${category}"))))
#+end_src
See the [[https://orgmode.org/manual/Template-expansion.html][template expansion docs]] for more info on the syntax here
Appending to existing templates to keep project templates
- [ ] figure out where existing templates are coming from, and migrate useful ones here
#+name: org-capture-templates
#+begin_src elisp :tangle no
;; setq
(setq org-capture-templates
 (append org-capture-templates
         (doct '(("Inbox"
                  :keys "i"
                  :file "~/.local/share/notes/gtd/inbox.org"
                  :template "* %?"
                  :kill-buffer t)
                 ("Email"
                  :keys "e"
                  :file "~/.local/share/notes/gtd/org-gtd-tasks.org"
                  :olp ("Email")
                  :template ("* TODO Reply: %a")
                  :kill-buffer t)
                 ("Today"
                  :keys "2"
                  :file "~/.local/share/notes/gtd/org-gtd-tasks.org"
                  :olp ("Calendar")
                  :hook +patch/doct-properties
                  ;; NOTE: Timestamp needs to be inactive (using the third arg
                  ;;       of org-insert-time-stamp) to avoid the OPENED date
                  ;;       appearing in the agenda.
                  :properties (:OPENED "%(org-insert-time-stamp (org-read-date nil t \"+0d\") nil t)")
                  :template ("* TODO %?"
                             "SCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))")
                  :prepare-finalize (lambda () (progn (org-priority)
                                                      (org-set-tags-command)))
                  :kill-buffer t)
                 ("Meeting"
                  :keys "m"
                  :children
                  (("Retro"
                    :keys "r"
                    :file "~/.local/share/notes/meetings/retro.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Nico 1:1"
                    :keys "n"
                    :file "~/.local/share/notes/meetings/nico.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Haotian 1:1"
                    :keys "h"
                    :file "~/.local/share/notes/meetings/haotian.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Parking Lot"
                    :keys "p"
                    :file "~/.local/share/notes/meetings/parking-lot.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Kinso"
                    :keys "k"
                    :file "~/.local/share/notes/meetings/kinso.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)))
                 ("Shopping" :keys "s"
                  :file "~/.local/share/notes/gtd/org-gtd-tasks.org"
                  :template "* %?"
                  :children
                  (("Home" :keys "h" :olp ("Projects" "home improvement"))
                   ("Christmas" :keys "c" :olp ("Projects" "christmas"))
                   ("Gift" :keys "g" :olp ("Projects" "gifts")) ; TODO either add recipient as tag or in olp
                   ("Groceries" :keys "o" :olp ("Projects" "groceries"))))
                 (:group "Reference"
                  :file "~/.local/share/notes/gtd/org-gtd-tasks.org"
                  :template "* %?"
                  :children
                  (("Food"
                    :keys "f"
                    :children
                    (("Recipe"     :keys "r" :olp ("Projects" "recipes"))
                     ("Cocktail"   :keys "c" :olp ("Projects" "cocktails"))
                     ("Restaurant" :keys "s" :olp ("Projects" "restaurants"))))
                   ("Media" :keys "d"
                    :children
                    (("Movie"   :keys "m" :olp ("Projects" "movies"))
                     ("Show"    :keys "s" :olp ("Projects" "shows"))
                     ("Book"    :keys "b" :olp ("Projects" "books"))
                     ("Article" :keys "a" :olp ("Projects" "articles"))
                     ("Album"   :keys "l" :olp ("Projects" "albums"))))
                   ("Repo" :keys "r" :olp ("Projects" "repos"))))))))
#+end_src
** capture everywhere
When I'm doing things outside of emacs, it would be nice to still use the same capture interface. I used to use org protocol plus an alfred command, but I opted for something that utilizes org-mode's typical capture interface, by popping up a new emacs frame and capturing from there.
Heavily inspired by [[https://macowners.club/posts/org-capture-from-everywhere-macos/][this blog post]] (for the majority of the logic) and [[https://github.com/tecosaur/emacs-everywhere][emacs-everywhere]] (borrowed the logic for getting back to the app I was in before capturing).
Similar to my setup for emacs-everywhere, I have an algfred workflow that uses a keybinding to trigger a script running `/usr/local/bin/emacsclient --eval "(capture-everywhere)"`.
#+begin_src elisp
(after! emacs-everywhere
  (defun get-app-name ()
    "Get the name of the current app (useful for returning to that app later). Currently uses osascript, so only useful on macos."
    (let ((default-directory emacs-everywhere--dir))
      (with-temp-buffer
        (call-process "osascript" nil t nil "app-name")
        (string-trim (buffer-string)))))

  (defun capture-everywhere ()
    "Create a new frame and run `org-capture'."
    (interactive)
    (require 'noflet)
    (make-frame `((name . "capture")
                  (top . 300)
                  (left . 700)
                  (width . 80)
                  (height . 25)
                  (emacs-everywhere-prior-app . ,(get-app-name))))

    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
            (org-capture)))


  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame and return to the app we came from"
    (when emacs-everywhere-window-focus-command
      (apply #'call-process (car emacs-everywhere-window-focus-command)
             nil nil nil
             (mapcar (lambda (arg)
                       (replace-regexp-in-string "%w" (frame-parameter nil 'emacs-everywhere-prior-app) arg))
                     (cdr emacs-everywhere-window-focus-command))))
    (delete-frame)))
#+end_src
* Agenda
#+begin_src emacs-lisp :noweb no-export
(use-package! org-agenda
  :commands org-agenda
  :custom
  <<agenda-files>>
  :config
  <<agenda-prefix>>
  <<sync-buffer-to-file>>
  <<sync-file-to-agenda>>
  <<agenda-reschedule>>)
#+end_src
** Agenda Files
Only track my task-related files in the agenda
#+name: agenda-files
#+begin_src elisp :tangle no
(org-agenda-files '("~/.local/share/notes/gtd/org-gtd-tasks.org"))
#+end_src
** Agenda format
Simplify the agenda prefix to only include what I need to see
#+name: agenda-prefix
#+begin_src emacs-lisp :tangle no
(setq org-agenda-prefix-format
      '((agenda . "  %?-12t")
        (todo   . " ")
        ;; should maybe come back to these next two, but haven't had a need for it yet
        (tags   . " %i %-12:c")
        (search . " %i %-12:c")))
#+end_src
** Sync
*** Save buffers when modifying todos (taken from [[https://emacs.stackexchange.com/a/33063/15634][this SO answer]])
#+name: sync-buffer-to-file
#+begin_src elisp :tangle no
(defmacro η (fnc)
  "Return function that ignores its arguments and invokes FNC."
  `(lambda (&rest _rest)
     (funcall ,fnc)))

(advice-add 'org-deadline       :after (η #'org-save-all-org-buffers))
(advice-add 'org-schedule       :after (η #'org-save-all-org-buffers))
(advice-add 'org-store-log-note :after (η #'org-save-all-org-buffers))
(advice-add 'org-todo           :after (η #'org-save-all-org-buffers))
(advice-add 'org-refile         :after (η #'org-save-all-org-buffers))
#+end_src
*** Update agenda after 5mins of idle time (inspired by [[https://emacs.stackexchange.com/a/47266/15634][this SO answer]]) [0/1]
- [ ] need to also sync file to buffer
#+name: sync-file-to-agenda
#+begin_src elisp :tangle no
(run-with-idle-timer 300 t (lambda () (save-window-excursion (org-agenda nil ","))))
#+end_src
** Change refile targets so I can refile to wherever I want from the agenda (e.g. my reference org files, and the inbox if I just want to reprocess a task completely)
#+begin_src emacs-lisp
(use-package! org-refile
  :after org-agenda
  :config
  (add-to-list 'org-refile-targets `(,(directory-files "~/.local/share/notes/reference" t ".*\\.org$") :maxlevel . 3))
  (add-to-list 'org-refile-targets `(,(directory-files "~/.local/share/notes/gtd" t ".*\\.org$") :maxlevel . 3)))
#+end_src
** Quick actions for rescheduling to today/tomorrow (used pretty commonly when things roll over)
#+name: agenda-reschedule
#+begin_src emacs-lisp :tangle no
(defun org-agenda-reschedule-to-today (&optional arg)
  "Reschedule selected task(s) for today."
  (interactive "P")
  (org-agenda-schedule arg "."))

(defun org-agenda-reschedule-to-tomorrow (&optional arg)
  "Reschedule selected task(s) for tomorrow."
  (interactive "P")
  (org-agenda-schedule arg "+1d"))

(setq org-agenda-bulk-custom-functions '((?. org-agenda-reschedule-to-today)
                                         (?> org-agenda-reschedule-to-tomorrow)))
(map! (:map org-agenda-mode-map "." #'org-agenda-reschedule-to-today)
      (:map evil-org-agenda-mode-map :m "." #'org-agenda-reschedule-to-today)
      (:map org-agenda-mode-map ">" #'org-agenda-reschedule-to-tomorrow)
      (:map evil-org-agenda-mode-map :m ">" #'org-agenda-reschedule-to-tomorrow))
#+end_src
** Quick actions for sending back to "incubate"
#+name: agenda-incubate-and-hatch
#+begin_src emacs-lisp :tangle no
(defun +patch/gen-org-refile-rfloc (file headline)
  "Format a specified file/heading for passing to org-refile and org-agenda-refile.

 FILE is the file to refile into.

 HEADLINE is the headline (inside FILE) to refile into."
  (let ((pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (list headline file nil pos)))

(defun +patch/refile-to-node (arg file headline)
  (org-agenda-refile arg (+patch/gen-org-refile-rfloc file headline)))

(defun +patch/org-agenda-refile (file headline)
  "Refile item at point to a particular place via org-agenda-refile, but
 with a simpler interface.

 FILE is the file to refile into.

 HEADLINE is the headline (inside FILE) to refile into."
  (save-window-excursion
    (org-agenda-refile nil (+patch/gen-org-refile-rfloc file headline))))

;; FIXME setting here instead of in :custom becuase it's not working in :custom (see note above)
(setq +patch/org-gtd-tasks-file (concat (file-name-as-directory org-gtd-directory) "org-gtd-tasks.org"))

(defun org-agenda-incubate (&optional arg)
  "Incubate a specified task (includes refiling to incubate section, and specifiying a date to review the task)"
  (interactive "P")
  (org-agenda-schedule arg)
  (+patch/org-agenda-refile +patch/org-gtd-tasks-file "Incubate"))

(defun org-agenda-hatch (&optional arg)
  "Un-incubate (or 'hatch') a specified task (includes refiling to calendar section, and specifiying the date to complete the task)"
  (interactive "P")
  (org-agenda-schedule arg)
  ;; (+patch/org-agenda-refile +patch/org-gtd-tasks-file "Calendar")
  ;; TODO save excursion, and refresh both org ql buffers
  (org-ql-view-refresh)
  )

(defun org-planning-hatch (&optional arg)
  "Un-incubate (or 'hatch') a specified task (includes refiling to calendar section, and specifiying the date to complete the task)"
  (interactive "P")

  ;; (+patch/org-agenda-refile +patch/org-gtd-tasks-file "Calendar")
  ;; TODO save excursion, and refresh both org ql buffers
  (org-agenda-schedule arg)
  (org-ql-view-refresh)
  (other-window 1)
  (org-ql-view-refresh)
  (other-window 1)
  )

(setq org-agenda-bulk-custom-functions
      (append org-agenda-bulk-custom-functions '((?i org-agenda-incubate)
                                                 (?h org-agenda-hatch)
                                                 (?] org-planning-hatch))))
(map! (:map org-agenda-mode-map "i" #'org-agenda-incubate)
      (:map org-agenda-mode-map "h" #'org-agenda-hatch)
      (:map org-agenda-keymap "h" #'org-agenda-hatch)
      (:map org-agenda-keymap "]" #'org-planning-hatch)
      (:map evil-org-agenda-mode-map "h" #'org-agenda-hatch)
      (:map evil-org-agenda-mode-map "]" #'org-planning-hatch)
      (:map evil-org-agenda-mode-map :m "i" #'org-agenda-incubate)
      (:map evil-org-agenda-mode-map :m "h" #'org-agenda-hatch)
      (:map evil-org-agenda-mode-map :m "]" #'org-planning-hatch))
#+end_src
** Super Agenda [0/9]
A few notes on this:
- including both "agenda" and "alltodo" lets you have both the agenda (with the time grid) /and/ the todo list
- I keep my active TODOs (i.e. the ones scheduled for today, except for "WAIT") in the agenda, and everything else in the todo list (I just want to declutter my agenda be removing anything I have to wait on, and therefore probably can't accurately predict when I can get it done)
- I use the order to split the view into 3 sections: the timeboxed agenda, the regular todo list, and the degenerate todos (unscheduled or overdue)
Future enhancements
- [ ] review the other org props I'm setting here
- [ ] filter "other tasks" after [[https://github.com/alphapapa/org-super-agenda/pull/149][this PR]] is merged (only include NEXT items for the next week or so)
- [ ] format overdue/unscheduled once [[https://github.com/alphapapa/org-ql/pull/44][org-ql formatting changes]] are merged
- [ ] sort sections once [[https://github.com/alphapapa/org-ql/issues/79][org-ql-block sorting]] is merged
#+begin_src elisp :noweb no-export
(use-package! org-super-agenda
  :after (org-ql org-agenda)
  :commands org-super-agenda-mode
  :hook (org-agenda-mode . org-super-agenda-mode)
  :custom
  (org-agenda-include-deadlines t)
  (org-agenda-tags-column 100) ;; from testing this seems to be a good value
  (org-agenda-compact-blocks t)
  (org-agenda-custom-commands
   `(
     <<daily-planning-agenda-view>>
     ("." "What's happening"
      ((agenda "" ((org-agenda-span 'day)
                   (org-agenda-start-day "+0d")
                   (org-super-agenda-groups
                    '((:name "Today"
                       :time-grid t
                       :and (:scheduled today
                             :not (:tag ("%quick" "%easy"))
                             :not (:todo ("DONE" "CNCL" "WAIT")))
                       :order 0)
                      (:name "Remove anything else"
                       :discard (:anything t))))))
       (org-ql-block '(and (tags "%quick")
                           (ts-a :on today)
                           (not (todo "WAIT"))
                           (not (done))
                           (not (regexp ,org-ql-regexp-scheduled-with-time)))
                     ((org-ql-block-header "\n Quick")))
       (org-ql-block '(and (tags "%easy")
                           (ts-a :on today)
                           (not (todo "WAIT"))
                           (not (done))
                           (not (regexp ,org-ql-regexp-scheduled-with-time)))
                     ((org-ql-block-header "\n Easy")))
       (org-ql-block '(and (ts-a :to -1)
                           (not (todo "WAIT"))
                           (not (done))
                           (level 2))
                     ((org-ql-block-header "\n Overdue")))
       (org-ql-block '(and (not (scheduled))
                           (not (done))
                           (not (tags "@@someday_maybe"))
                           (level 2))
                     ((org-ql-block-header "\n Unscheduled")))
       (org-ql-block '(and (todo "WAIT"))
                     ((org-ql-block-header "\n Waiting")))
       (org-ql-block '(closed :on today)
                     ((org-ql-block-header "\n Completed today")))
       (org-ql-block '(and (tags ("%quick" "%easy"))
                           (ts-a :from +1 :to +3))
                     ((org-ql-block-header "\n Could pull in"))))))))
#+end_src
Use evil bindings on agenda headers created by super agenda (using best-looking solution from [[https://github.com/alphapapa/org-super-agenda/issues/50][this issue]])
- [ ] should do a proper evil-ification of this eventually
#+begin_src elisp
(after! evil-org-agenda
  (setq org-super-agenda-header-map (copy-keymap evil-org-agenda-mode-map)))
#+end_src
** Planning Agenda
Notably, this is where I'm defining what a task vs project are:
- a task is any task without children
- a project is a task under the "Projects" header that has children
#+begin_src emacs-lisp :noweb no-export
(use-package! org-ql
  :after org-agenda
  :custom
  (org-super-agenda-date-format "%e %B %Y - %A")
  :defines (+patch/set-orgql-view +patch/is-action)
  :config
  ;; have to setq instead of :custom bc we need access to org-ql vars (so we need it executed after the package is loaded, and :custom seems to be executed before the package is loaded)
  <<planning-defs-orgql>>
  <<view-planning-props-orgql>>
  <<planning-predicates-orgql>>
  (setq
   +patch/daily-agenda-super-groups
   `((:name "Today"
      :time-grid t
      :and (:scheduled today
            :not (:tag ("%quick" "%easy"))
            :not (:todo ("DONE" "CNCL" "WAIT")))
      :order 0)
     (:name "Quick"
      :and (:tag "%quick"
            :scheduled today
            :not (:todo ("DONE" "CNCL" "WAIT"))
            :not (:regexp ,org-ql-regexp-scheduled-with-time)))
     (:name "Easy"
      :and (:tag "%easy"
            :scheduled today
            :not (:todo ("DONE" "CNCL" "WAIT"))
            :not (:regexp ,org-ql-regexp-scheduled-with-time)))
     (:name "Overdue"
      :and (:scheduled past
            :face error
            :not (:todo ("DONE" "CNCL" "WAIT"))))
     ;; TODO omiting this for now, until I decide on semantics for unscheduled project items and action list items
     ;; (:name "Unscheduled"
     ;;  :face error
     ;;  :and (:scheduled nil
     ;;        :not (:todo "DONE")))
     (:name "Waiting"
      :todo "WAIT")
     (:name "Completed Today"
      ;; TODO would be nice to include "CLOSED" today, rather than basing on scheduled time (but :log closed doesn't seem to be working for me)
      :and (:todo "DONE"
            :scheduled today))
     (:name "Could Pull In"
      :and (:tag ("%quick" "%easy")
            ;; scheduled in the next 3 days
            :scheduled future
            :scheduled (before ,(org-read-date nil nil "+4"))))
     (:name "Remove anything else"
      :discard (:anything t)))

   +patch/daily-agenda-query
   '(and (or (ts-active :on today)
             (scheduled :to +3)
             (scheduled :before today))
         (not (children))
         (not (todo "CNCL")))

   org-ql-views
   `(("Planning" :buffers-files
      ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query
      (and
       ;; only include tasks
       ,+patch/is-action
       ;; Get upcoming and unscheduled tasks
       (or (ts :from today :to +45)
           (and (not (scheduled)) (level 2)))
       ;; only get tasks that are still "todo"
       ;; (not (tags "Incubate"))
       (not (todo "WAIT" "DONE" "CNCL"))
       (not (tags "@@someday_maybe")))
      :sort
      (priority todo)
      :narrow nil
      :super-groups ((:name "Unscheduled"
                      :scheduled nil
                      :face error
                      :order 0)
                     (:auto-planning t))
      :title "Planning")
     ("Last Month" :buffers-files
      ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query
      (and
       ;; Get upcoming and unscheduled tasks
       (or (ts :from (ts-format "%Y-%m-%d" (make-ts :day 1 :month (ts-month (ts-now)) :year (ts-year (ts-now))))
               :to +45)
           (and (not (scheduled)) (level 2)))
       ;; only get tasks that are still "todo"
       ;; (not (tags "Incubate"))
       (not (todo "WAIT" "DONE" "CNCL"))
       (not (tags "@@someday_maybe")))
      :sort
      (priority todo)
      :narrow nil
      :super-groups ((:name "Unscheduled"
                      :scheduled nil
                      :face error
                      :order 0)
                     (:auto-planning t))
      :title "Last Month")
     ("Daily"
      :buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query ,+patch/daily-agenda-query
      :sort (priority todo date)
      :narrow nil
      :super-groups ,+patch/daily-agenda-super-groups
      :title "Daily")
     ("Home"
      :buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query '(and (tags "@home" "@work" "@anywhere")
                   ,+patch/daily-agenda-query)
      :sort (priority todo date)
      :narrow nil
      :super-groups ,+patch/daily-agenda-super-groups
      :title "Home")
     ("Work"
      :buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query '(and (tags "@work" "@anywhere")
                   ,+patch/daily-agenda-query)
      :sort (priority todo date)
      :narrow nil
      :super-groups ,+patch/daily-agenda-super-groups
      :title "Work")
     ("Email"
      :buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query '(and (tags "@email")
                   ,+patch/daily-agenda-query)
      :sort (priority todo date)
      :narrow nil
      :super-groups ,+patch/daily-agenda-super-groups
      :title "Email")))
       <<orgql-view-setter>>
       <<yearly-planning-orgql-views>>
       <<quarterly-planning-orgql-views>>
       <<weekly-planning-orgql-views>>


  (defun org-ql-action-list (action-list-name)
    (interactive (list (completing-read "Action List: " (--filter (string-match-p "^\@.*" it) (mapcar #'car org-tag-alist)))))
    (org-ql-search "~/.local/share/notes/gtd/org-gtd-tasks.org"
      `(and ,+patch/daily-agenda-query
            (tags "@anywhere" ,action-list-name))
      :title (format "%s action list" action-list-name)
      :super-groups +patch/daily-agenda-super-groups))

  (defun org-ql-refine-view (query)
    (interactive "xQuery: ")
    (let ((org-ql-view-query `(and ,query ,org-ql-view-query)))
      (org-ql-view-refresh))))
#+end_src
** Automatically collapse sections of my daily agenda I don't need often [0/1]
Also allow myself to (semi-permanently) expand sections that are useful to regularly see depending on what's in them.
#+begin_src elisp
(use-package! origami
  :after (org-agenda)
  :hook ((org-agenda-mode . origami-mode)
         (org-agenda-finalize . +patch/org-super-agenda-origami-fold-default))
  :config
  (setq +patch/agenda-auto-hide-groups '("Waiting" "Completed Today" "Could Pull In"))
  (defun +patch/org-super-agenda-origami-fold-default ()
    "Fold certain groups by default in Org Super Agenda buffer."
    (evil-goto-first-line)

    (--each +patch/agenda-auto-hide-groups
      (goto-char (point-min))
      (when (re-search-forward (rx-to-string `(seq bol " " ,it)) nil t)
        (origami-close-node (current-buffer) (point))))

    (beginning-of-buffer))

  (defun +patch/dont-show-waiting-in-agenda ()
    (interactive)
    (setq +patch/agenda-auto-hide-groups
          (cons "Waiting" +patch/agenda-auto-show-groups))
    (org-agenda-redo))

  (defun +patch/show-waiting-in-agenda ()
    (interactive)
    (setq +patch/agenda-hide-show-groups
          (remove "Waiting" +patch/agenda-auto-show-groups))
    (org-agenda-redo))

  (map!
   (:map evil-org-agenda-mode-map "TAB" #'origami-toggle-node)
   (:map evil-org-agenda-mode-map :m "<tab>" #'origami-toggle-node)
   (:map evil-org-agenda-mode-map :m "TAB" #'origami-toggle-node)
   (:map org-super-agenda-header-map :m "<tab>" #'origami-toggle-node)
   (:map org-super-agenda-header-map :m "TAB" #'origami-toggle-node)
   (:map org-super-agenda-header-map "TAB" #'origami-toggle-node)
   (:map org-agenda-keymap "TAB" #'origami-toggle-node)
   (:map org-agenda-keymap "<tab>" #'origami-toggle-node)
   (:map org-agenda-mode-map "TAB" #'origami-toggle-node)
   (:map org-agenda-mode-map "<tab>" #'origami-toggle-node)
   :map org-agenda-mode-map
   :localleader
   ("w" #'+patch/show-waiting-in-agenda)
   ("W" #'+patch/dont-show-waiting-in-agenda)))


#+end_src
* Export
** Set pandoc executeable, so it looks at the right one
#+begin_src emacs-lisp
(use-package! ox-pandoc
  :after ox
  :custom (org-pandoc-command "/usr/local/bin/pandoc"))
  ;; m1 path
  ;; :custom (org-pandoc-command "/opt/homebrew/bin/pandoc"))
#+end_src
* Deft
#+begin_src elisp
(use-package! deft
  :after org
  :custom
  (deft-directory "~/.local/share/notes")
  (deft-recursive t))
#+end_src
* General
** Notes directory
Top-level note directory, synced with Syncthing
#+name: notes-directory
#+begin_src elisp :tangle no
(setq org-directory "~/.local/share/notes")
#+end_src
** Render latex fragments when opening org file
#+name: latex-on-startup
#+begin_src elisp :tangle no
(setq org-startup-with-latex-preview t)
#+end_src
also make sure emacs can find mactex executeables (from [[https://stackoverflow.com/a/44914143/5054505][this SO answer]])
#+begin_src emacs-lisp
;; (setenv "PATH" (concat ":/Library/TeX/texbin/" (getenv "PATH")))
(add-to-list 'exec-path "/Library/TeX/texbin/")
#+end_src
and resolve weird "dvi wasn't produced please adjust 'dvipng' part of 'org-preview-latex-process-alist'" error (from [[https://stackoverflow.com/questions/3517165/pdflatex-command-not-working-in-emacs-terminal-mode][this SO post]])
#+begin_src emacs-lisp
(defun set-exec-path-from-shell-PATH ()
  (let ((path-from-shell
         (replace-regexp-in-string "[[:space:]\n]*$" ""
           (shell-command-to-string "$SHELL -l -c 'echo $PATH'"))))
    (setenv "PATH" path-from-shell)
    (setq exec-path (split-string path-from-shell path-separator))))
(when (equal system-type 'darwin) (set-exec-path-from-shell-PATH))
#+end_src
** Word wrap
Commenting this out for now; doom seems to do a good job of this on its own
#+begin_src elisp
;(setq org-startup-truncated nil)
;(setq org-startup-indented t)
#+end_src
** Refile
Commenting this out for now, unless I decide I need it
#+begin_src elisp
;(setq org-refile-targets
;      '((nil :maxlevel . 3)
;        (org-agenda-files :maxlevel . 3)))
#+end_src
* Babel [0/1]
- [ ] TODO revisit these
  #+begin_src emacs-lisp :noweb no-export
(after! org
  <<babel-evaluate>>
  <<babel-inline-images>>
  <<invoke-babel>>)
#+end_src
** Confirm evaluate
Don't prompt me to confirm every time I want to evaluate a block
#+name: babel-evaluate
#+begin_src elisp :tangle no
(setq org-confirm-babel-evaluate nil)
#+end_src
** Inline images
Display/udate images in the buffer after I evaluate a block
#+name: babel-inline-images
#+begin_src elisp :tangle no
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src
** Mermaid
Use [[https://mermaid-js.github.io/mermaid/#/][mermaid.js]] to generate diagrams in org files (rendered by babel)
Notably, you'll need to install [[https://github.com/mermaid-js/mermaid-cli][mermaid-cli]].
#+begin_src elisp
(use-package! ob-mermaid
  :defer t
  :config
  (setq ob-mermaid-cli-path "/usr/local/bin/mmdc"))
#+end_src
* Pomodoro [0/1]
- [ ] need to see if I can set slack status in pomodoro hooks
#+begin_src elisp :noweb no-export
(use-package! org-pomodoro
  :after org-agenda
  :custom
  ; my personal pomodoro lengths
  (org-pomodoro-length 40)
  (org-pomodoro-short-break-length 10)
  (org-pomodoro-long-break-length 30)
  ; wait for me to start my break
  (org-pomodoro-manual-break t)
  ; only record pomodoro-approved time: overtime doesn't get clocked
  (org-pomodoro-overtime-hook '(org-clock-out))
  ; dont use annoying multiple bell after long break
  (org-pomodoro-long-break-sound org-pomodoro-short-break-sound)
  :config
  <<clockreport-format>>
  (defun +org/switch-task (&optional arg)
    (interactive "P")
    (org-agenda-clock-out)
    (org-agenda-clock-in arg))
  (map! :after org-agenda
        :leader
        (:prefix "n"
         :desc "pomodoro" "p" #'org-pomodoro)
        :map org-agenda-mode-map
        :localleader
        (:prefix ("c" . "clock")
         :desc "switch task" "w" #'+org/switch-task
         :desc "pomodoro" "p" #'org-pomodoro)))
#+end_src

This gives some useful summary info about time spent on tasks from the agenda, when you have the discipline to use org's clock features.

Oh my god, this is complicated without some background knowledge... see the [[https://orgmode.org/manual/The-clock-table.html][clocktable docs]] for info on setting this var, see [[https://orgmode.org/manual/The-Spreadsheet.html][the spreadsheet docs]] for info on the formula (the [[https://orgmode.org/manual/References.html][references docs]] are a good starting point), and just know that this is using calc under the hood with (what seems to be) org specific additions for the table references.
I have not been able to find a way to change the column names for the clockreport.
My setting here is originally based on [[https://emacs.stackexchange.com/a/12883/15634][this SE answer]].
The save-window-excursion is here bc for some reason formatting the clockreport is leaving the agenda buffer (so I have to navigate to the agenda explicitly after loading it)
  #+name: clockreport-format
  #+begin_src emacs-lisp :tangle no
(setq org-agenda-clockreport-parameter-plist
   `(:link t :maxlevel 2 :formula ,(format "$5=ceil(($3+$4)*60/%s);N" org-pomodoro-length)))
#+end_src

* Tags
Make my most frequently used tags quickly available.
Use [[https://orgmode.org/guide/Tags.html][fast tag selection]] to make this a little easier. Notably, you can use TAB from the fast tag interface to enter a tag free-form.
Use [[https://orgmode.org/manual/Setting-Tags.html][tag groups]] to make contexts mutually exclusive.
The system here is that "@" tags denote context (e.g. I can only do this task at home), and "%" tags denote restrictions (e.g. I only have time to do a quick task). The "@@someday_maybe" is sort of a meta-context, because any project with this tag is it's own context (e.g. these are recipes I want to try one day).
- [ ] need to link to someday/maybe docs here when I have them semi-polished.
#+name: tag-list
#+begin_src elisp :tangle no
(setq org-tag-alist '((:startgroup . nil)
                      ("@home"           . ?h)
                      ("@work"           . ?w)
                      ("@comp"           . ?c)
                      ("@cheryls"        . ?y)
                      ("@parents"        . ?p)
                      ("@errands"        . ?r)
                      ("@phone"          . ?o)
                      ("@email"          . ?m)
                      ("@book"           . ?b)
                      ("@anywhere"       . ?a)
                      (:endgroup . nil)
                      ("@@someday_maybe" . ?s)
                      ("@@aspirational"  . ?z)
                      ("%quick"          . ?q)
                      ("%easy"           . ?e)))
#+end_src
* Codeblocks
** Keep parinfer from constantly asking if it can indent things
#+begin_src emacs-lisp
(use-package! parinfer-rust-mode
  :after parinfer
  :custom
  (parinfer-rust-check-before-enable nil))
#+end_src
** poly-org for better language support in code blocks
Not starting automatically, as I'm still running into a few issues so far.
#+begin_src emacs-lisp :tangle yes
(use-package! poly-org
  :after org)
#+end_src
* Styling
** Bullets
#+begin_src elisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t))

(after! org-fancy-priorities
  (setq org-ellipsis " ▾ "
        org-hide-leading-stars t
        org-priority-highest ?A
        org-priority-lowest ?E
        org-fancy-priorities-list
        `(,(list ?A (all-the-icons-octicon "flame" :face 'all-the-icons-red))
          ,(list ?B (all-the-icons-faicon "bolt" :face 'all-the-icons-orange))
          ,(list ?C (all-the-icons-faicon "check" :face 'all-the-icons-yellow))
          ,(list ?D (all-the-icons-faicon "beer" :face 'all-the-icons-green))
          ,(list ?E (all-the-icons-faicon "bed" :face 'all-the-icons-blue)))))
#+end_src
** org-modern
#+begin_src elisp :noweb no-export
(use-package! org-modern
  :after org
  :hook
  (org-mode . org-modern-mode)
  ;; until I figure out how to keep org-modern from inverting face on agenda priorities, leave off org-modern-agenda
  ;;(org-agenda . org-modern-agenda)
  :custom
  (org-modern-priority nil)
  (org-modern-internal-target `(,(all-the-icons-material "redo" :face 'all-the-icons-blue) t " "))
  (org-modern-star ["◉" "○" "✸" "✿" "✤" "✜" "◆"])
  <<org-modern-todo-faces>>

  (org-modern-list '((43 . "➤")
                     (45 . "–")
                     (42 . "•"))))
#+end_src
* General org config
#+begin_src emacs-lisp :noweb no-export
(use-package! org
  :commands org-mode
  :config
  <<tag-list>>
  <<latex-on-startup>>
  <<notes-directory>>
  <<todo-keywords>>
  <<state-changes-in-logbook>>)
#+end_src
* Planning Views
These are the views I use to plan my tasks. I review my tasks periodically, with varying levels of depth:
- Yearly, I review all of my tasks. I throw away things that aren't relevant anymore, and determine roughly what I want to get done this year.
- Quarterly, I check in on my progress and revisit what I'm expecting to get done this year
- Weekly, I check in on my progress and schedule top-priority tasks for the week
- Daily, I can see what I need to get done and filter based on context
** Burly
Burly can save window configurations so they can be quickly opened later on.
I had to wrestle it a bit to get a somewhat declarative syntax for this though, and need to come back and clean this up (and maybe make a PR, since I figure this would be useful in the package).
| Keybinding | Description                  |
|------------+------------------------------|
| DEL v y    | Open yearly planning view    |
| DEL v q    | Open quarterly planning view |
| DEL v w    | Open weekly planning view    |
| DEL v d    | Open daily planning view     |

#+begin_src emacs-lisp :tangle packages.el
(package! burly)
#+end_src
#+begin_src emacs-lisp :noweb no-export
(use-package burly
  :after org-ql
  :commands (burly-open-bookmark +patch/toggle-quick-agenda-filter +patch/refresh-weekly-planning-view +patch/gen-and-show-daily-agenda)
  :defines (+patch/toggle-quick-agenda-filter +patch/refresh-weekly-planning-view +patch/gen-and-show-daily-agenda)
  :init
  (map! (:map (evil-normal-state-map evil-org-agenda-mode-map org-super-agenda-header-map org-agenda-keymap)
              (:prefix-map ("DEL" . "GTD")
                           (:prefix ("v" . "Planning Views")
                            :desc "Yearly Planning"     "y" #'+patch-gtd/planning/yearly-planning-layout
                            :desc "Quarterly Planning"  "q" #'+patch-gtd/planning/quarterly-planning-layout
                            :desc "Weekly Planning"     "w" #'+patch-gtd/planning/weekly-planning-layout
                            ;; :desc "Refresh Weekly Data" "W" #'+patch/refresh-weekly-planning-view
                            :desc "Daily Planning"      "d" #'+patch-gtd/planning/daily-planning-layout
                            :desc "Inbox"               "i" #'+patch-gtd/planning/inbox-layout)
                           (:prefix ("p" . "Planning Actions")
                            :desc "Mark as 'to-plan'"       "p" #'+patch-gtd/planning/move-to-planning-queue
                            :desc "Mark as READY"           "r" #'+patch-gtd/planning/move-ready
                            :desc "Open this quarter"       "o" #'+patch-gtd/planning/agenda-open-this-quarter-move
                            :desc "Punt to another quarter" "u" #'+patch-gtd/planning/agenda-punt-move
                            ))
              "<backspace>" nil
              :m "<backspace>" nil
              "<delete>" nil
              :m "<delete>" nil)

        (:leader
         (:prefix "b" :desc "Open Burly Bookmark" "o" #'burly-open-bookmark)))
  :config
  <<yearly-planning-view>>
  <<quarterly-planning-view>>
  <<quarterly-planning-utils>>
  <<weekly-planning-view>>
  <<daily-planning-cmds>>
  <<daily-planning-view>>
  (defun +patch-gtd/planning/inbox-layout ()
    (interactive)
    (+patch/open-window-layout '(delete-other-windows
                                 "~/.local/share/notes/gtd/inbox.org"
                                 delete-other-windows)))
  )
#+end_src
*** layout-building functions
#+begin_src emacs-lisp
(defun +patch/bookmark-org-ql-view (org-ql-view-name)
    (bookmark-store
     (format "Org QL View: %s" org-ql-view-name)
     (list (cons 'org-ql-view-plist (alist-get org-ql-view-name org-ql-views nil nil #'string=))
           '(handler . org-ql-view-bookmark-handler))
     nil))

;; heavily inspired by the yequake code for setting up buffers
(defun +patch/open-window-layout (buffer-refs-or-fns)
  "Show buffers or run functions in order defined in BUFFER-REFS-OR-FNS."
  (cl-flet ((open-buffer-or-call-fn (it) (cl-typecase it
                        (string (or (get-buffer it)
                                    (find-buffer-visiting it)
                                    (find-file-noselect it)))
                        (function (funcall it)))))
    (let ((split-width-threshold 0)
          (split-height-threshold 0))
      ;; Switch to first buffer, pop to the rest.
      (switch-to-buffer (open-buffer-or-call-fn (car buffer-refs-or-fns)))
      (dolist (buffer-ref-or-fn (cdr buffer-refs-or-fns))
        (when-let* ((ret (open-buffer-or-call-fn buffer-ref-or-fn)))
          (display-buffer-same-window ret nil))))))
#+end_src
*** yearly planning
This is a process that I do yearly, where I go through all of my tasks and get everything into a good state. It takes a while, but it's getting faster and it's worth it to keep everything up-to-date (plus it doesn't take too long if you're doing it regularly). My process is to:
1. Tidy/normalize my tasks file
  - set TODO/NEXT items to READY
  - remove any priority designations (they'll be determined later)
  - archive any tasks that aren't relevant anymore
2. Choose my "all wishes granted" list of tasks for the year. I mark everything I might be able to get done as "TODO"
3. The tasks I chose consist of both actions (no subtasks necessary) and projects. For each project, I make a first pass on a list of actions and set them as TODO. Then I mark non-blocked actions as NEXT and put actions they block below them (org edna will mark any TODO as NEXT when the task above is completed)
4. Next, I compare the number of actions I have with how many I got done last year. Many additional things will have come up, but I make a judgement call on how reasonable I think my number of tasks is. Everything I don't think I'll be able to do is marked as READY and given an "@@aspirational" tag.
5. Finally, I roughly assign tasks to quarters. This just gives my a genaral sense of what I can safely ignore at the beginning of the year.
**** review functions
This isn't smoothly integrated yet, but it tells me how many tasks I completed last year.
- [ ] Brainstorm a process for comparing the number of tasks completed last year to what I have in my all-wishes-granted list. Eventually, it'd be nice for this to consider the fact that I'll pull more tasks in throughout the year.
#+name: yearly-review-fns
#+begin_src emacs-lisp :tangle no
(after! ts
  (after! org-ql
    (defun num-tasks-finished-last-year (&optional as-of)
      (let* ((first-of-this-year-ts (ts-apply :month 1 :day 1 :hour 0 :minute 0 :second 0 (or as-of (ts-now))))
             (first-of-last-year-ts (ts-dec 'year 1 first-of-this-year-ts))
             (last-of-last-year-ts (ts-apply :day 0 first-of-this-year-ts))
             (first-of-last-year (ts-format first-of-last-year-ts))
             (last-of-last-year (ts-format last-of-last-year-ts))
             (tasks (org-ql-select (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
                      `(and (todo "DONE" "CNCL")
                            (closed :from ,first-of-last-year :to ,last-of-last-year)))))
        (length tasks)))

    (defun num-tasks-todo ()
      (let* ((tasks (org-ql-select (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
                      `(and (todo "TODO" "NEXT")
                            (not (ancestors (todo "TODO" "NEXT")))))))

        (length tasks)))))
#+end_src

**** view
A view of my upcoming year. On the left, I can see all TODO/NEXT projects (or actions whose parent isn't TODO/NEXT), grouped by outline path. I can "move" them to the right side (grouped by date) by scheduling the task and refreshing the views (which I have automated into a function)
- [ ] Refine this process; the logic for determining what's on the right/left is based on when the task is scheduled, plus it'd be nice to use something like calfw rather than an org-ql view grouped on date
#+name: orgql-view-setter
#+begin_src emacs-lisp :tangle no
(defun +patch/set-orgql-view (view-name view-spec)
  (let ((view (assoc view-name org-ql-views)))
    (if view
        (setf (cdr view) view-spec)
      (add-to-list 'org-ql-views `(,view-name . ,view-spec)))))
#+end_src

#+name: planning-defs-orgql
#+begin_src emacs-lisp :tangle no
(setq
  +patch/is-project '(and (ancestors "Projects") (children))
  +patch/is-action '(not (children)))

#+end_src


#+name: yearly-planning-orgql-views
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/set-or-refresh-yearly-views ()
  (setq
   +patch/is-top-level-selected-task '(and (todo "TODO" "NEXT")
                                           (not (ancestors (todo "TODO" "NEXT"))))
   +patch/is-planned `(and ,+patch/is-top-level-selected-task
                           (not (to-plan)))
   +patch/to-be-planned `(and ,+patch/is-top-level-selected-task
                              (to-plan)))

  (+patch/set-orgql-view
   "This Year's Projects"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query ,+patch/to-be-planned
     :sort (priority todo)
     :narrow nil
     :super-groups ((:auto-outline-path t))
     :title "This Year's Projects"))

  (+patch/set-orgql-view
   "Yearly Planning"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query ,+patch/is-planned
     :sort (priority todo)
     :narrow nil
     :super-groups ((:auto-planning t))
     :title "Yearly Planning"))

  (+patch/set-orgql-view
   "Actions In-Queue"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query (and (todo "TODO" "NEXT") (not (to-plan)) ,+patch/is-action)
     :sort (priority todo)
     :narrow nil
     :super-groups ((:auto-outline-path t))
     :title "Actions In-Queue"))

  (+patch/set-orgql-view
   "Projects In-Queue"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query (and ,+patch/is-planned ,+patch/is-project)
     :sort (priority todo)
     :narrow nil
     :super-groups ((:auto-outline-path t))
     :title "Projects In-Queue")))

(+patch-gtd/set-or-refresh-yearly-views)
#+end_src

#+name: yearly-planning-view
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/planning/yearly-planning-layout ()
  (interactive)
  (+patch-gtd/set-or-refresh-yearly-views)
  (+patch/open-window-layout '(delete-other-windows
                             (lambda () (org-ql-view "Yearly Planning"))
                             delete-other-windows
                             split-window-horizontally
                             (lambda () (enlarge-window (/ (frame-width) 10) t))
                             (lambda () (org-ql-view "This Year's Projects"))
                             (lambda () (evil-window-right 1)))))

#+end_src
*** quarterly planning
Every quarter, I check in on my progress on what I'm hoping to accomplish this year (plus re-assess my goals for the year). The goal is to revisit what I have planned (and remove things that don't seem important anymore or add things that are important now), and get a rough (about monthly) timeline for when to focus on what (mainly so I can know what's safely ignore-able early in the quarter).
**** view
A view of my upcoming quarter. On the right I can see all TODO/NEXT actions (as opposed to projects in the year view) grouped by outline path. I can "move" actions to the right by scheduling them for a date in this quarter.
- [ ] Fix the logic here once I refine my process for planning vs scheduling tasks
#+name: quarterly-planning-orgql-views
#+begin_src emacs-lisp :tangle no
(defun +patch/start-of-this-quarter-ts (&optional as-of)
  (let* ((base-ts (or as-of (ts-now)))
         (base-date (ts-apply :hour 0 :minute 0 :second 0 base-ts))
         (this-month (ts-month base-date))
         (last-month-of-quarter (cond ((< this-month 4) 3)
                                      ((< this-month 7) 6)
                                      ((< this-month 10) 9)
                                      (t 12))))
    (ts-dec 'month 2 (ts-apply :month last-month-of-quarter :day 1 base-date))))

(defun +patch/end-of-this-quarter-ts (&optional as-of)
  (let* ((base-ts (or as-of (ts-now)))
         (base-date (ts-apply :hour 0 :minute 0 :second 0 base-ts))
         (this-month (ts-month base-date))
         (last-month-of-quarter (cond ((< this-month 4) 3)
                                      ((< this-month 7) 6)
                                      ((< this-month 10) 9)
                                      (t 12)))
         (first-month-of-next-quarter (ts-inc 'month 1 (ts-apply :month last-month-of-quarter :day 1 base-date))))
    (ts-dec 'second 1 first-month-of-next-quarter)))

(defun +patch/start-of-last-quarter-ts (&optional as-of)
  (let* ((base-ts (or as-of (ts-now)))
         (start-of-this-quarter (+patch/start-of-this-quarter-ts as-of)))
    (ts-dec 'month 3 start-of-this-quarter)))

(defun +patch/end-of-last-quarter-ts (&optional as-of)
  (let* ((base-ts (or as-of (ts-now)))
         (start-of-this-quarter (+patch/start-of-this-quarter-ts as-of)))
    (ts-dec 'second 1 start-of-this-quarter)))

(defun +patch-gtd/set-or-refresh-quarterly-views ()
  (setq
   planned-for-this-quarter (let* ((end-of-quarter (+patch/end-of-this-quarter-ts)))
                              `(or (scheduled :to ,(ts-format end-of-quarter))
                                   (ancestors (scheduled :to ,(ts-format end-of-quarter)))))
   scheduled-for-this-quarter `(scheduled :from ,(ts-format (+patch/start-of-this-quarter-ts))
                                :to ,(ts-format (+patch/end-of-this-quarter-ts)))
   opened-this-quarter `(opened :from ,(ts-format (+patch/start-of-this-quarter-ts))
                         :to ,(ts-format (+patch/end-of-this-quarter-ts))))

  (defun +patch/num-tasks-completed-last-quarter (&optional as-of)
    (length
     (org-ql-query
       :from (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
       :where `(closed :from ,(ts-format (+patch/start-of-last-quarter-ts as-of)) :to ,(ts-format (+patch/end-of-last-quarter-ts as-of))))))

  (defun +patch/num-tasks-planned-for-this-quarter (&optional as-of)
    (length
     (org-ql-query
       :from (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
       :where `(opened :from ,(ts-format (+patch/start-of-this-quarter-ts as-of)) :to ,(ts-format (+patch/end-of-this-quarter-ts as-of))))))

  (+patch/set-orgql-view
   "This Quarter's Projects"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query (and
             (todo "TODO" "NEXT")
             ,+patch/is-action
             ,opened-this-quarter
             (not (scheduled)))
     :sort (priority todo)
     :narrow nil
     :super-groups ((:auto-outline-path t))
     :title "This Quarter's Projects"))

  (+patch/set-orgql-view
   "Quarterly Planning"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query (and
             (todo "TODO" "NEXT")
             ,+patch/is-action
             ,opened-this-quarter)
     :sort (priority todo)
     :narrow nil
     :super-groups ((:auto-planning t))
     :title ,(format "[Completed last quarter: %s] [Planned for this quarter: %s]" (+patch/num-tasks-completed-last-quarter) (+patch/num-tasks-planned-for-this-quarter)))))

(+patch-gtd/set-or-refresh-quarterly-views)
#+end_src

#+name: quarterly-planning-view
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/planning/quarterly-planning-layout ()
  (interactive)
  (+patch-gtd/set-or-refresh-quarterly-views)
  (+patch/open-window-layout '(delete-other-windows
                             (lambda () (org-ql-view "Quarterly Planning"))
                             delete-other-windows
                             split-window-horizontally
                             (lambda () (enlarge-window (/ (frame-width) 10) t))
                             (lambda () (org-ql-view "This Quarter Projects"))
                             (lambda () (evil-window-right 1)))))
#+end_src

Some helpful utilities for my quarterly review
#+name: quarterly-planning-utils
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/planning/move-to-planning-queue ()
  (interactive)
  (+patch-gtd/planning/agenda-mark-task-for-planning)
  (org-ql-view-refresh))

(defun +patch-gtd/planning/move-ready ()
  (interactive)
  (+patch-gtd/planning/incubate)
  (org-ql-view-refresh))

(defun +patch-gtd/planning/open-this-quarter (&optional pom)
  (interactive)
  (org-entry-delete (or pom (point)) "TO-PLAN")
  (+patch/set-opened-date (or pom (point)) (ts-format (+patch/start-of-this-quarter-ts))))

(defun +patch-gtd/planning/agenda-open-this-quarter ()
  (interactive)
  (+patch--from-source-of-agenda-entry
   (+patch-gtd/planning/open-this-quarter)))

(defun +patch-gtd/planning/agenda-open-this-quarter-move ()
  (interactive)
  (+patch-gtd/planning/agenda-open-this-quarter)
  (org-ql-view-refresh))

(defun +patch-gtd/planning/punt (&optional pom)
  (interactive)
  (org-entry-delete (or pom (point)) "TO-PLAN")
  ;; (+patch/try (org-entry-delete (or pom (point)) "TO-PLAN"))
  (+patch/set-opened-date (or pom (point))))

(defun +patch-gtd/planning/agenda-punt ()
  (interactive)
  (+patch--from-source-of-agenda-entry
   (+patch-gtd/planning/punt)))

(defun +patch-gtd/planning/agenda-punt-move ()
  (interactive)
  (+patch-gtd/planning/agenda-punt)
  (org-ql-view-refresh))
#+end_src

#+RESULTS:
: +patch-gtd/planning/agenda-punt-move

**** review functions
These get me the tasks for this quarter, and eventually I'd like to better use this for quarterly planning. For now they're mostly used for the burnup chart in my weekly planning.
#+name: quarterly-review-elisp-fns
#+begin_src emacs-lisp :tangle no
(after! ts
  (after! org-ql
    (defun get-org-ql-closed (item)
      (plist-get (cadr item) :closed))

    (defun get-org-ql-closed-day (item)
      (let* ((closed-ts-raw (plist-get (cadr (get-org-ql-closed item)) :raw-value)))
        (ts-format "\"%Y-%m-%d\"" (ts-parse closed-ts-raw))))

    (defun my-ts< (left right)
      (ts< (ts-parse (car left)) (ts-parse (car right))))

    (defun num-tasks-todo ()
      (let* ((tasks (org-ql-select (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
                      `(and (todo "TODO" "NEXT")
                            (not (ancestors (todo "TODO" "NEXT")))))))

        (length tasks)))

    (defun num-tasks-finished-last-quarter-by-day (&optional as-of)
      (let* ((first-of-this-month-ts (ts-apply :day 1 :hour 0 :minute 0 :second 0 (or as-of (ts-now))))
             (first-of-last-month-ts (ts-dec 'month 3 first-of-this-month-ts))
             (last-of-last-month-ts (ts-apply :day 0 first-of-this-month-ts))
             (first-of-last-month (ts-format first-of-last-month-ts))
             (last-of-last-month (ts-format last-of-last-month-ts))
             (tasks (org-ql-select (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
                      `(and (todo "DONE")
                            (closed :from ,first-of-last-month :to ,last-of-last-month))))
             (task-groups (seq-group-by #'get-org-ql-closed-day tasks))
             (first-task-group (car task-groups))
             (day-counts (mapcar (lambda (task-group)
                                   (cons (car task-group) (list (length (cdr task-group)))))
                                 task-groups)))
        (sort day-counts #'my-ts<)))))
#+end_src
#+name: quarterly-review-fns
#+begin_src emacs-lisp
(after! ts
  (after! org-ql

    (defun +patch/org-element-contents (element)
      "Get the contents of the partially specified 'element' that only consists of '(TYPE PROPS)'."
      (let ((beg (org-element-property :contents-begin element))
            (end (org-element-property :contents-end element)))
        (buffer-substring-no-properties beg end)))

    (defun +patch/maybe-parse-element-date (prop-name task)
      (let ((value (org-element-property prop-name task)))
        (when value
          (ts-format "%Y-%m-%d" (ts-parse-org-element value)))))

    (defun +patch/find-and-parse-task ()
      (+patch/parse-task (org-element-at-point)))

    (defun +patch/parse-task (raw-task)
      (when raw-task
        `(,(org-element-property :raw-value raw-task)
          ,(let ((todo-keyword (org-element-property :todo-keyword raw-task)))
             (when todo-keyword (prin1-to-string (read todo-keyword))))
          ,(prin1-to-string (org-element-property :todo-type raw-task))
          ,(+patch/maybe-parse-element-date :closed raw-task)
          ,(+patch/maybe-parse-element-date :scheduled raw-task)
          ,(+patch/get-opened-date raw-task))))

    (defun this-quarters-tasks (&optional as-of)
      (org-ql-query
        :select #'+patch/find-and-parse-task
        :from (cons "~/.local/share/notes/gtd/org-gtd-tasks.org" (f-glob "gtd_archive_[0-9][0-9][0-9][0-9]" "~/.local/share/notes/gtd"))
        :where `(or ,opened-this-quarter
                    ;; keeping scheduled so this quarter is still accurate, but this should be removed afterward
                    ,scheduled-for-this-quarter)))))

#+end_src

*** weekly planning
Every week I process my inbox, check in on my progress on my quarterly goals, and schedule a rough timeline for the week (I try to limit the planning to the most important 2-ish tasks I really need to get done each day so I can be flexible about getting things done)
**** burnup chart generation
Generate burnup plot. Currently, this is done via a hack where I just run the following babel blocks to re-generate the plot each time I need to update it.
I generate a burnup chart of this quarter's tasks for myself to see in my weekly planning view.
- Right now, this is done in a hacky way where I get my tasks in elisp, then pass them to python (via babel), and write out the burnup to a file (in a known location, so I can open it in the weekly planning view). One downside of this is that I don't seem to be able to refresh and load the view in the same function (the whole view gets broken, and I haven't figured out why yet).
***** utilities for executing babel blocks
This let's me execute babel blocks from anywhere using elisp (modified from [[https://emacs.stackexchange.com/a/510/15634][this SE post]])
#+name: invoke-babel
#+begin_src emacs-lisp :tangle no :results silent
(defun +patch/invoke-babel-named (file-path block-name)
  (interactive)
  (save-excursion
    (with-current-buffer (find-file-noselect file-path)
      (org-babel-goto-named-src-block block-name)
      (org-babel-execute-src-block-maybe))))

(defvar +patch/babel-hashes 'nil)
(defun +patch/babel-hashed-confirm (lang body)
  (let ((check (list lang (md5 body))))
    ;; If not hashed, prompt
    (if (not (member (list lang (md5 body)) +patch/babel-hashes))
        ;; Ask if you want to hash
        (if (yes-or-no-p "Store hash for block? ")
            ;; Hash is added, proceed with evaluation
            (progn
              (add-to-list '+patch/babel-hashes check)
              'nil)
          ;; Return 't to prompt for evaluation
          't))))

(setq org-confirm-babel-evaluate '+patch/babel-hashed-confirm)
#+end_src

***** generate plot
These are the babel blocks that need to be run to re-generate the burnup chart for this quarter (executed using the function below).
#+begin_src emacs-lisp
(defun +patch/generate-quarters-burnup-plot ()
  (interactive)
  (+patch/invoke-babel-named "~/.config/doom/modules/lang/org-patch/config.org" "quarters-tasks")
  (+patch/invoke-babel-named "~/.config/doom/modules/lang/org-patch/config.org" "plot-quarters-tasks"))
#+end_src

#+name: quarters-tasks
#+begin_src emacs-lisp :tangle no :results silent
(this-quarters-tasks)
#+end_src
#+name: plot-quarters-tasks
#+begin_src jupyter-python :session burnup :var burnup_data=quarters-tasks :tangle no :results silent
import pandas as pd
import numpy as np
import matplotlib
import seaborn as sns

def is_this_quarter(col):
    return (col.isna()
            | ((col.dt.year == today.year)
               & (col.dt.quarter == today.quarter)))

today = pd.Timestamp.today()
tasks = pd.DataFrame(burnup_data, columns=["headline", "todo_state", "is_done", "closed", "scheduled", "opened"])
tasks["scheduled"] = pd.to_datetime(tasks["scheduled"].map(lambda val: val or ""))
tasks["closed"] = pd.to_datetime(tasks["closed"].map(lambda val: val or ""))
tasks["opened"] = pd.to_datetime(tasks["opened"].map(lambda val: val or ""))

# if a task was quickly completed (without ever scheduling), count the
# "scheduled" time as the "completed" time.
def earliest_time(times):
    t1, t2 = times
    if pd.isna(t1):
        return t2
    if pd.isna(t2):
        return t1
    return min(t1, t2)

tasks["scheduled"] = tasks[["scheduled", "closed"]].apply(earliest_time, axis=1)


def is_starting_date(col):
    starting_date = today - pd.tseries.offsets.QuarterBegin(startingMonth=1)
    return ((~col.isna())
            & (col >= starting_date))

this_quarter_index = pd.date_range(start=today - pd.tseries.offsets.QuarterBegin(startingMonth=1),
                                   end=today + pd.tseries.offsets.QuarterEnd(),
                                   freq="D", normalize=True)
burnup_counts = pd.DataFrame({
    "opened": tasks.groupby("opened").count()["headline"],
    "scheduled": tasks.groupby("scheduled").count()["headline"],
    "closed": tasks.groupby("closed").count()["headline"],
}, index=this_quarter_index).asfreq("D").fillna(0.0).cumsum()
# burnup_counts["ideal"] = np.linspace(0, len(df), num=len(burnup_counts))
# TODO I can go back to using 'len(df)' once I'm using my opened conventions better
burnup_counts["ideal"] = np.linspace(0, burnup_counts.opened.max(), num=len(burnup_counts))

xtick_positions = [p for p in burnup_counts.index if p.is_month_start]
xtick_labels = [l.strftime('%B') for l in xtick_positions]
ax = burnup_counts.plot(title="This Quarter's Burnup",
                        xlabel="Date",
                        ylabel="# of Tasks",
                        xticks=xtick_positions,
                        x_compat=True)
ax.set_xticklabels(xtick_labels)
def get_ts(dt):
    return pd.Timestamp(pd.Timestamp.date(dt) )
today_ts = get_ts(today)
y_offset = 5
today_x_text_coord = get_ts(today-pd.Timedelta(10, unit='D'))
last_ts = burnup_counts.index[-1]
last_x_text_coord = get_ts(last_ts+pd.Timedelta(5, unit='D'))
for col, color in zip(["opened", "scheduled", "closed", "ideal"], sns.color_palette()):
    today_val = burnup_counts.at[today_ts, col]
    last_val = burnup_counts.at[last_ts, col]
    ax.annotate(int(today_val),
                xy=(today_ts, today_val),
                xytext=(today_x_text_coord, today_val+y_offset),
                arrowprops=dict(arrowstyle="->", color=color),
                color=color)
    ax.annotate(int(last_val),
                xy=(last_ts, last_val),
                xytext=(last_x_text_coord, last_val+y_offset),
                arrowprops=dict(arrowstyle="->", color=color),
                color=color)
ax.get_figure().savefig("./quarters-burnup.png")
#+end_src

**** view
The view for my weekly planning has all actions currently scheduled (up until the first day of this week) on the left (grouped by outline path). On the top right is all tasks scheduled for this week, grouped by day. On the bottom right, I have the burnup chart for this quarter.
#+name: weekly-planning-orgql-views
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/set-or-refresh-weekly-views ()
  (setq
   scheduled-for-this-week (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                                  (dow (ts-day-of-week-num today))
                                  (start-of-week (ts-dec 'day dow today))
                                  (start-of-next-week (ts-inc 'day (- 6 dow) (ts-now)))
                                  (end-of-week (ts-dec 'second 1 start-of-next-week)))
                             `(scheduled
                               :from ,(ts-format start-of-week)
                               :to ,(ts-format end-of-week)))
   scheduled-around-this-week (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                                     (dow (ts-day-of-week-num today))
                                     (start-of-week (ts-dec 'day dow today))
                                     (start-of-period (ts-dec 'day 3 start-of-week))
                                     (start-of-next-week (ts-inc 'day (- 6 dow) (ts-now)))
                                     (end-of-week (ts-dec 'second 1 start-of-next-week))
                                     (end-of-period (ts-inc 'day 3 end-of-week)))
                                `(scheduled
                                  :from ,(ts-format start-of-period)
                                  :to ,(ts-format end-of-period)))
   scheduled-til-this-week (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                                  (dow (ts-day-of-week-num today))
                                  (start-of-week (ts-dec 'day dow today)))
                             `(scheduled
                               :to ,(ts-format start-of-week)))
   scheduled-through-this-week (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                                      (dow (ts-day-of-week-num today))
                                      (start-of-week (ts-dec 'day dow today))
                                      (start-of-next-week (ts-inc 'day (- 6 dow) (ts-now)))
                                      (end-of-week (ts-dec 'second 1 start-of-next-week)))
                                 `(scheduled
                                   :to ,(ts-format end-of-week)))
   opened-through-this-week (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                                   (dow (ts-day-of-week-num today))
                                   (start-of-week (ts-dec 'day dow today))
                                   (start-of-next-week (ts-inc 'day (- 6 dow) (ts-now)))
                                   (end-of-week (ts-dec 'second 1 start-of-next-week)))
                              `(opened
                                :to ,(ts-format end-of-week)))
   due-this-week (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                        (dow (ts-day-of-week-num today))
                        (start-of-week (ts-dec 'day dow today))
                        (start-of-next-week (ts-inc 'day (- 6 dow) (ts-now)))
                        (end-of-week (ts-dec 'second 1 start-of-next-week)))
                   `(deadline :from ,(ts-format start-of-week) :to ,(ts-format end-of-week)))
   due-this-week-sa (let* ((today (ts-apply :hour 0 :minute 0 :second 0 (ts-now)))
                           (dow (ts-day-of-week-num today))
                           (start-of-week (ts-dec 'day dow today))
                           (start-of-next-week (ts-inc 'day (- 7 dow) (ts-now)))
                           (end-of-week (ts-dec 'second 1 start-of-next-week)))
                      `(before ,(prin1-to-string (ts-format "%Y-%m-%d" start-of-next-week)))))

  (+patch/set-orgql-view
   "This Week's Projects"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query (and
             (todo "TODO" "NEXT")
             ,+patch/is-action
             (not ,scheduled-around-this-week)
             (or
              ,opened-through-this-week
              ,due-this-week))
     :sort (priority todo)
     :narrow nil
     :super-groups ((:name "Upcoming Deadline"
                     :and (:deadline ,due-this-week-sa
                           :not (:todo ("DONE" "CNCL" "WAIT")))
                     :face error
                     :order 0)
                    (:auto-outline-path t))
     :title "This Week's Projects"))

  (+patch/set-orgql-view
   "Weekly Planning"
   `(:buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
     :query (and
             (todo "TODO" "NEXT")
             ,+patch/is-action
             (or (scheduled :to today) ,scheduled-around-this-week))
     :sort (priority todo)
     :narrow nil
     :super-groups ((:name "Overdue"
                     :and (:scheduled past
                           :face error
                           :not (:todo ("DONE" "CNCL" "WAIT"))))
                    (:auto-planning t))
     :title "Weekly Planning")))

(+patch-gtd/set-or-refresh-weekly-views)
(+patch/refresh-weekly-planning-view)
#+end_src

   #+RESULTS: weekly-planning-orgql-views
   | :buffers-files | (~/.local/share/notes/gtd/org-gtd-tasks.org) | :query | (and (todo TODO NEXT) (not (children)) (scheduled :from 2023-04-27 00:00:00 -0700 :to 2023-05-09 15:33:37 -0700)) | :sort | (priority todo) | :narrow | nil | :super-groups | ((:name Overdue :and (:scheduled past :face error :not (:todo (DONE CNCL WAIT)))) (:auto-planning t)) | :title | Weekly Planning |

#+name: weekly-planning-view
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/planning/weekly-planning-layout ()
  (interactive)
  (+patch-gtd/set-or-refresh-weekly-views)
  (+patch/generate-quarters-burnup-plot)
  (+patch/open-window-layout '(delete-other-windows
                               (lambda () (org-ql-view "Weekly Planning"))
                               delete-other-windows
                               split-window-horizontally
                               (lambda () (enlarge-window (/ (frame-width) 10) t))
                               (lambda () (org-ql-view "This Week's Projects"))
                               (lambda () (evil-window-right 1))
                               ;; other-window
                               split-window-vertically
                               (lambda () (evil-window-down 1))
                               "~/.config/.../.config/doom/modules/lang/org-patch/quarters-burnup.png"
                               (lambda () (evil-window-up 1)))))
#+end_src
*** daily planning
At the beginning of each day, I look at my most important tasks for the day (either the ones I scheduled in weekly planning, or whatever I've prioritized throughout the week) and I roughly plan out my day.
I view my schedule via an org agenda view, with macros to filter the agenda by context (using tags), or filter to only quick/easy tasks (by filtering on special "%easy"/"%quick" tags).
Agenda keybindings for filtering:
| Keybinding | Description                                                             |
|------------+-------------------------------------------------------------------------|
| - q        | Limit agenda to %quick tasks                                            |
| - e        | Limit agenda to %easy tasks                                             |
| - a        | Filter agenda to a context (determined by prompting the user for a tag) |
| - DEL      | Clear all filters on the agenda                                         |
#+name: daily-planning-cmds
#+begin_src emacs-lisp :tangle no
(defun +patch/is-substr (comparison-string query-string)
  (string-match-p (regexp-quote query-string) comparison-string))

(defun +patch/agenda-filter-already-applied (tag-name)
  (seq-contains-p org-agenda-tag-filter tag-name #'+patch/is-substr))

(defun +patch/remove-match-from-seq (query-string seq)
  (seq-remove (lambda (elt) (+patch/is-substr elt query-string)) seq))

(defun +patch/remove-agenda-tag-filter (tag-name)
  (setq org-agenda-tag-filter (+patch/remove-match-from-seq tag-name org-agenda-tag-filter))
  (org-agenda-redo))

(defun +patch/set-quick-agenda-tag ()
  "Annoyingly, I have to do this manually since org-agenda-filter-by-tag accepts ?q as a 'quit' argument."
  (setq org-agenda-tag-filter
        (cons "+%quick" org-agenda-tag-filter))
  (org-agenda-filter-apply org-agenda-tag-filter 'tag))

(defun +patch/toggle-quick-agenda-filter ()
  (interactive)
  (if (+patch/agenda-filter-already-applied "%quick")
      (+patch/remove-agenda-tag-filter "%quick")
    (+patch/set-quick-agenda-tag)))

(defun +patch/toggle-easy-agenda-filter ()
  (interactive)
  (if (+patch/agenda-filter-already-applied "%easy")
      (+patch/remove-agenda-tag-filter "%easy")
    (org-agenda-filter-by-tag '(16) ?e))) ; prefix arg to accumulate tags (rather than just replacing)

(map! (:map evil-motion-state-map
       :desc "temporarily delete kbd to avoid 'non-prefix key' error, also this always annoyed me anyway" "-" nil)
      (:map (evil-org-agenda-mode-map org-super-agenda-header-map org-agenda-keymap)
       :desc "temporarily delete kbd to avoid 'non-prefix key' error" "-" nil
       :desc "temporarily delete kbd to avoid 'non-prefix key' error" :m "-" nil
       (:prefix ("-" . "Filter Agenda")
        :desc "Toggle %quick filter"  "q"   #'+patch/toggle-quick-agenda-filter
        :desc "Toggle %easy filter"   "e"   #'+patch/toggle-easy-agenda-filter
        :desc "Filter by action list" "a"   #'org-agenda-filter
        :desc "Clear filters"         "DEL" #'org-agenda-filter-remove-all)))
#+end_src
#+name: daily-planning-view
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/planning/daily-planning-layout ()
  (interactive)
  (+patch/open-window-layout '(delete-other-windows
                             (lambda () (org-agenda nil ","))
                             delete-other-windows)))
#+end_src
#+name: daily-planning-agenda-view
#+begin_src emacs-lisp :tangle no
("," "Today"
 ((agenda "" ((org-agenda-span 'day)
              (org-agenda-start-day "+0d")
              (org-super-agenda-groups
               '((:name "Agenda"
                  :time-grid t
                  :and (:scheduled today
                        :regexp ,org-ql-regexp-scheduled-with-time
                        :not (:todo ("DONE" "CNCL" "WAIT")))
                  :order 0)
                 (:name "Remove anything else"
                  :discard (:anything t))))))
  (org-ql-block '(and (scheduled :on +0)
                      (not (children)) ; only look at actions, not projects
                      (not (todo "DONE" "CNCL" "WAIT" "INCUBATE"))
                      (regexp ,org-ql-regexp-scheduled-without-time))
                ((org-ql-block-header "\n Today")))
  (org-ql-block '(and (scheduled
                       ;; :from ,(->> (ts-now)
                       ;;             (ts-adjust 'day (- (ts-dow (ts-now))))
                       ;;             (ts-apply :hour 0 :minute 0 :second 0))
                       :to -1)
                      (not (children)) ; only look at actions, not projects
                      (todo "NEXT" "TODO")
                      (not (done)))
                ((org-ql-block-header "\n Overdue")))
  (org-ql-block '(and (todo "WAIT"))
                ((org-ql-block-header "\n Waiting")))
  (org-ql-block '(closed :on today)
                ((org-ql-block-header "\n Completed today")))))
#+end_src
* Inbox Processing
When processing my inbox, the biggest degree of freedom is typically "when do I need to get this done?".
- if it's something I just want to get around to one day, just file it into my gtd file and come back to it in the regular planning cycle
- if I want to get to this relatively soon (i.e. it's relevant to something I'm working on in the current planning cycle), then I need to put it in my "queue" and pull it in soonish
- if I need to get this done today, or in the next few days, I need to get it on the calendar

Outside of that, I like to have to option to quickly change attributes when appropriate, but otherwise just stick with the reasonable defaults.

I'm using a [[https://github.com/magit/transient][transient]] to define my interface for this. (Notably, the [[https://github.com/positron-solutions/transient-showcase][transient-showcase]] was helpful for understanding how to put a transient together.)

#+begin_src emacs-lisp :tangle packages.el
(package! bufler)
#+end_src
#+begin_src emacs-lisp :noweb no-export
(use-package! transient
  :config
  <<transient-preset>>
  (after! org
    <<gtd/set-task-atrs>>
    <<gtd/inbox-processing-transient>>))
#+end_src

Preset utils from [[https://github.com/magit/transient/issues/183][this GH issue]]
#+name: transient-preset
#+begin_src emacs-lisp :tangle no
(defclass transient-preset (transient-infix)
  ((transient                            :initform t)
   (format      :initarg :format         :initform " %k %d %v")
   (arguments   :initarg :arguments))
  "Class used for command-line arguments presets.")

(cl-defmethod transient-init-value ((obj transient-preset))
  "if default values match the arguments slot of transient_preset then set its init value to t"
  (oset obj value
        (seq-set-equal-p (oref obj arguments)
                         (oref transient--prefix value))))

(cl-defmethod transient-infix-read ((obj transient-preset))
  "Toggle the preset on or off setting all the arguments to corresponding infixes."
  (pp (transient-args transient-current-command))
  (seq-set-equal-p (oref obj arguments)
                   (transient-args transient-current-command)))

(cl-defmethod transient-infix-set ((obj transient-preset) value)
  "Toggle the preset on or off setting all the arguments to corresponding infixes."
  (oset obj value value)
  (unless value
    (oset transient--prefix value (oref obj arguments))
    (mapc #'transient-init-value transient--suffixes)))

(cl-defmethod transient-format-value ((obj transient-preset))
  (propertize
   (concat "[" (mapconcat 'identity (oref obj arguments) " ") "]")
   'face (if (oref obj value)
             'transient-argument
           'transient-inactive-argument)))

(cl-defmethod transient-infix-value ((_ transient-preset))
  "Return nil, which means \"no value\"."
  nil)

#+end_src
My function for setting my typical attributes for a task
#+name: gtd/set-task-atrs
#+begin_src emacs-lisp :tangle no
(defun +patch-gtd/set-task-attrs (&optional todo tags opened-date scheduled-date rfloc goto-task)
  "For any args provided, apply the value to the appropriate field of the task
at point.

If GOTO-TASK is specified, narrow to the task after applying properties so the
user can make any appropriate edits."
  (when todo (org-todo todo))
  (when tags (org-set-tags tags))
  (when opened-date (+patch/set-opened-date nil opened-date))
  (when scheduled-date (org-schedule nil scheduled-date))
  (when rfloc (org-refile nil nil rfloc))
  (when goto-task
    (push-mark (point))
    (org-refile '(16) nil rfloc)
    (org-tree-to-indirect-buffer)
    (+patch/refine-project-mode t)
    (push (lambda () (pop-global-mark) (pop +patch--widen-hooks)) +patch--widen-hooks)))
#+end_src
Transient for setting task attributes
#+name: gtd/inbox-processing-transient
#+begin_src emacs-lisp :tangle no
(defun +patch--get-tags ()
  "Get tags from user using 'org-fast-tag-selection'. Mostly taken from the
implementation of 'org-set-tags-command'."
  (let* ((all-tags (org-get-tags))
         (local-table (or org-current-tag-alist (org-get-buffer-tags)))
         (table (setq org-last-tags-completion-table
                      (append
                       ;; Put local tags in front.
                       local-table
                       (cl-set-difference
                        (org--tag-add-to-alist
                         (and org-complete-tags-always-offer-all-agenda-tags
                              (org-global-tags-completion-table
                               (org-agenda-files)))
                         local-table)
                        local-table))))
         (current-tags
          (cl-remove-if (lambda (tag) (get-text-property 0 'inherited tag))
                        all-tags))
         (inherited-tags
          (cl-remove-if-not (lambda (tag) (get-text-property 0 'inherited tag))
                            all-tags)))

    (org-fast-tag-selection
     current-tags
     inherited-tags
     table
     (and org-fast-tag-selection-include-todo org-todo-key-alist))))

(transient-define-infix +patch-gtd/planning/tag-infix ()
  :description "Tags"
  :class 'transient-option
  :always-read t
  :shortarg "-q"
  :argument "--tags="
  :reader (lambda (prompt _default-location _history)
            (+patch--get-tags)))

(transient-define-infix +patch-gtd/planning/refile-infix ()
  :description "Refile Location"
  :class 'transient-option
  :always-read t
  :shortarg "-r"
  :argument "--refile="
  :reader (lambda (prompt _default-location _history)
            (when (fboundp 'org-refile-get-location)
              (let* ((rfloc (org-refile-get-location "Where should the task be filed?"))
                     (rfloc-text (car rfloc)))
                ;; NOTE: Store full rfloc as property of the text, so that
                ;;       transient can display and we can still retrieve the
                ;;       full object later.
                (propertize rfloc-text 'rfloc rfloc)))))

(transient-define-infix +patch-gtd/planning/todo-infix ()
  :description "Todo State"
  :class 'transient-option
  :always-read t
  :shortarg "-t"
  :argument "--todo="
  :reader (lambda (prompt _default-location _history)
            (when (fboundp 'org-fast-todo-selection)
              (org-fast-todo-selection))))

(transient-define-infix +patch-gtd/planning/opened-date-infix ()
  :description "Opened Date"
  :class 'transient-option
  :always-read t
  :shortarg "-o"
  :argument "--opened-date="
  :reader 'transient-read-date)

(transient-define-infix +patch-gtd/planning/scheduled-date-infix ()
  :description "Scheduled Date"
  :class 'transient-option
  :always-read t
  :shortarg "-s"
  :argument "--scheduled-date="
  :reader 'transient-read-date)

;; "presets" that set typical combinations of infix args
(transient-define-infix +patch-gtd/planning/someday-maybe-preset ()
  :class transient-preset
  :arguments '("--todo=READY"))

(transient-define-infix +patch-gtd/planning/in-queue-preset ()
  :class transient-preset
  :arguments `("--todo=TODO" ,(format "--opened-date=%s" (org-read-date nil nil "today"))))

(transient-define-infix +patch-gtd/planning/to-schedule-preset ()
  :class transient-preset
  :arguments `("--todo=NEXT"
               ,(format "--opened-date=%s"
                        (ts-format "%Y-%m-%d" (ts-apply :hour 0 :minute 0 :second 0 (ts-now))))))

(transient-define-suffix +patch-gtd/apply-task-attrs ()
  "Set whichever attributes are necessary for the task being processed."
  :transient nil
  (interactive)
  (let* ((urgency (transient-arg-value "--urgency=" (transient-args '+patch-gtd/process-inbox-item)))
         (todo (transient-arg-value "--todo=" (transient-args '+patch-gtd/process-inbox-item)))
         (rfloc (let ((rfloc-text (transient-arg-value "--refile=" (transient-args '+patch-gtd/process-inbox-item))))
                  (if rfloc-text
                      (get-text-property 0 'rfloc rfloc-text)
                    nil)))
         (tags (transient-arg-value "--tags=" (transient-args '+patch-gtd/process-inbox-item)))
         (opened-date (transient-arg-value "--opened-date=" (transient-args '+patch-gtd/process-inbox-item)))
         (scheduled-date (transient-arg-value "--scheduled-date=" (transient-args '+patch-gtd/process-inbox-item))))
    (when (and (not scheduled-date) (equal urgency "to-schedule"))
      (setq scheduled-date (org-read-date)))
    (+patch-gtd/set-task-attrs todo tags opened-date scheduled-date rfloc)))

(transient-define-suffix +patch-gtd/apply-task-attrs-and-goto-task ()
  "Set whichever attributes are necessary for the task being processed, then
narrow to the task to make any appropriate edits."
  :transient nil
  (interactive)
  (let* ((urgency (transient-arg-value "--urgency=" (transient-args '+patch-gtd/process-inbox-item)))
         (todo (transient-arg-value "--todo=" (transient-args '+patch-gtd/process-inbox-item)))
         (rfloc (let ((rfloc-text (transient-arg-value "--refile=" (transient-args '+patch-gtd/process-inbox-item))))
                  (if rfloc-text
                      (get-text-property 0 'rfloc rfloc-text)
                    nil)))
         (tags (transient-arg-value "--tags=" (transient-args '+patch-gtd/process-inbox-item)))
         (opened-date (transient-arg-value "--opened-date=" (transient-args '+patch-gtd/process-inbox-item)))
         (scheduled-date (transient-arg-value "--scheduled-date=" (transient-args '+patch-gtd/process-inbox-item))))
    (+patch-gtd/set-task-attrs todo tags opened-date scheduled-date rfloc t)))


(transient-define-prefix +patch-gtd/process-inbox-item ()
  "Process a task from the inbox, setting whichever task attributes are
necessary for the particular task."
  :value '("--todo=READY")
  ["Presets"
   ("s" "Someday/Maybe" +patch-gtd/planning/someday-maybe-preset)
   ("q" "In-Queue" +patch-gtd/planning/in-queue-preset)
   ("t" "To-Schedule" +patch-gtd/planning/to-schedule-preset)]
  ["Task Attributes"
   (+patch-gtd/planning/opened-date-infix)
   (+patch-gtd/planning/scheduled-date-infix)
   (+patch-gtd/planning/refile-infix)
   (+patch-gtd/planning/todo-infix)
   (+patch-gtd/planning/tag-infix)
   ]
  ["Apply"
   ("x" "apply and eXit" +patch-gtd/apply-task-attrs)
   ("d" "apply and eDit" +patch-gtd/apply-task-attrs-and-goto-task)])
#+end_src

* bufler
for grouping buffers
#+begin_src emacs-lisp :tangle packages.el
(package! bufler)
#+end_src
#+begin_src emacs-lisp :tangle yes
(setq bufler-groups (bufler-defgroups
    (group
     ;; Subgroup collecting all named workspaces.
     (auto-workspace))
    (group
     ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
     (group-or "*Help/Info*"
               (mode-match "*Help*" (rx bos "help-"))
               (mode-match "*Info*" (rx bos "info-"))))
    (group
     ;; Subgroup collecting all special buffers (i.e. ones that are not file-backed),
     ;; except certain ones like Dired, Forge, or Magit buffers (which are allowed to
     ;; fall through to other groups, so they end up grouped with their project buffers).
     (group-not "*Special"
                (group-or "*Special*"
                          (mode-match "Magit" (rx bos "magit-"))
                          (mode-match "Forge" (rx bos "forge-"))
                          (mode-match "Dired" (rx bos "dired"))
                          (mode-match "grep" (rx bos "grep-"))
                          (mode-match "compilation" (rx bos "compilation-"))
                          (auto-file)))
     (group
      ;; Subgroup collecting these "special special" buffers
      ;; separately for convenience.
      (name-match "**Special**"
                  (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace") "*")))
     (group
      ;; Subgroup collecting all other Magit buffers, grouped by directory.
      (mode-match "*Magit* (non-status)" (rx bos "magit-"))
      (auto-directory))
     ;; Subgroup for Helm buffers.
     (mode-match "*Helm*" (rx bos "helm-"))
     ;; Remaining special buffers are grouped automatically by mode.
     (auto-mode))
    (group-or
     "gtd"
     (name-match "Org QL" (rx bos "*Org QL View:"))
     ;(name-match "Burnup Chart" (rx eos "-burnup*"))
     (dir "~/.local/share/notes/gtd"))
    (group-or
     "notes"
     (dir "~/.local/share/notes"))
    (group-or
     "..."
     (dir "~/.config/..."))
    ;; All buffers under "~/.emacs.d" (or wherever it is).
    (dir user-emacs-directory)
    (group
     ;; Subgroup collecting buffers in `org-directory' (or "~/org" if
     ;; `org-directory' is not yet defined).
     (dir (if (bound-and-true-p org-directory)
              org-directory
            "~/org"))
     (group
      ;; Subgroup collecting indirect Org buffers, grouping them by file.
      ;; This is very useful when used with `org-tree-to-indirect-buffer'.
      (auto-indirect)
      (auto-file))
     ;; Group remaining buffers by whether they're file backed, then by mode.
     (group-not "*special*" (auto-file))
     (auto-mode))
    (group
     ;; Subgroup collecting buffers in a projectile project.
     (auto-projectile)
     (group-not "special"
                ;; This subgroup collects special buffers so they are
                ;; easily distinguished from file buffers.
                (group-or "Non-file-backed and neither Dired nor Magit"
                          (mode-match "Magit Status" (rx bos "magit-status"))
                          (mode-match "Dired" (rx bos "dired-"))
                          (auto-file))))
    (group
     ;; Subgroup collecting buffers in a version-control project,
     ;; grouping them by directory (using the parent project keeps,
     ;; e.g. git worktrees with their parent repos).
     (auto-parent-project)
     (group-not "special"
                ;; This subgroup collects special buffers so they are
                ;; easily distinguished from file buffers.
                (group-or "Non-file-backed and neither Dired nor Magit"
                          (mode-match "Magit Status" (rx bos "magit-status"))
                          (mode-match "Dired" (rx bos "dired-"))
                          (auto-file))))
    ;; Group remaining buffers by directory, then major mode.
    (auto-directory)
    (auto-mode)))
#+end_src
