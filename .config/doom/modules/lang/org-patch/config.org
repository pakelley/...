#+TITLE: Config
#+property: header-args:emacs-lisp :tangle yes
#+property: header-args:elisp :tangle yes

* Packages
#+begin_src elisp :tangle packages.el
(package! deft)
(package! noflet)
(package! ob-mermaid)
(package! org-anki)
(package! org-gtd)
(package! org-ref)
(package! org-pomodoro)
(package! doct)
(package! org-super-agenda :pin "fb5e2ef277bc811a3b061106c99e4c47b6b86f80")
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "87772a9469d91770f87bfa788580fca69b9e697a")


(package! org-modern)
(package! org-ql)
(package! origami)
(package! ox-pandoc)
(package! poly-org)
#+end_src

* GTD
** Keybindings
Global keybindings:
| Keybinding | Description                       |
|------------+-----------------------------------|
| c          | Capture (to inbox file)           |
| e          | Engage (go to GTD agenda)         |
| p          | Process inbox                     |
| P          | Open planning agenda              |
| d          | Open daily agenda                 |
| a          | Open an agenda for an action list |
| n          | Show all NEXT tasks               |
| s          | Show projects that are stuck      |
| A          | Archive completed tasks           |
Keybindings while processing a task:
| Keybinding | Description   |
|------------+---------------|
| C-c C-c    | Finalize task |
#+begin_src elisp :noweb no-export
(use-package! org-gtd
  :after (org org-ql)
  ;; TODO this isn't being set properly using :custom, need to debug why when I have a chance
  ;;:custom
  ;;(+patch/org-gtd-tasks-file (concat (file-name-as-directory org-gtd-directory) "org-gtd-tasks.org"))
  :init
  <<org-gtd-directory>>
  <<org-gtd-recommendations>>
  <<org-gtd-edna>>
  <<agenda-incubate-and-hatch>>
  (map! (:leader (:prefix-map ("G" . "GTD")
                  :desc "Capture"             "c" #'org-gtd-capture
                  :desc "Engage"              "e" #'org-gtd-engage
                  :desc "Process Inbox"       "p" #'org-gtd-process-inbox
                  :desc "Plan"                "P" (lambda () (interactive) (org-ql-view "Planning"))
                  :desc "Daily Agenda"        "d" (lambda () (interactive) (org-ql-view "Daily"))
                  :desc "Action List"         "a" #'org-ql-action-list
                  :desc "Show all next"       "n" #'org-gtd-show-all-next
                  :desc "Show stuck projects" "s" #'org-gtd-show-stuck-projects
                  :desc "Capture"             "c" #'org-gtd-capture
                  :desc "Archive Done"        "A" #'org-gtd-archive-completed-items))
        (:map org-gtd-process-map       "C-c C-c" #'org-gtd-choose)))
#+end_src
** GTD Files
Store GTD files in XDG-based path, sync-ed by Syncthing
#+name: org-gtd-directory
#+begin_src elisp :tangle no
(setq org-gtd-directory "~/.local/share/notes/gtd/")
#+end_src
** Other Recommended config
These are suggested by the `org-gtd` README: set tags when processing tasks, add a `DELEGATED_TO` property, and add an agenda keybinding to the agenda
#+name: org-gtd-recommendations
#+begin_src elisp :tangle no
(setq org-gtd-process-item-hooks '(org-set-tags-command))
#+end_src
** `org-edna` config for GTD
Right now this is only the recommendations from `org-gtd`, but I'll probably add more eventually.
#+name: org-gtd-edna
#+begin_src elisp :tangle no
(setq org-edna-use-inheritance t)
(org-edna-mode 1)
#+end_src
* Roam
#+begin_src elisp :noweb no-export
(use-package! org-roam
  :after doct
  :custom
  <<org-roam-directory>>
  <<org-roam-completion-everywhere>>
  :config
  <<doct-org-roam>>
  <<org-roam-capture-templates>>
  ;; start org-roam on startup
  (org-roam-db-autosync-mode))
#+end_src
** Roam Files
Store `org-roam` files in XDG-based path, sync-ed by Syncthing
#+name: org-roam-directory
#+begin_src elisp :tangle no
(org-roam-directory "~/.local/share/notes/zettelkasten/")
#+end_src
** Roam completion everywhere
On the fence about this one, need to check on the performance. Makes linking roam notes together simple though, so I'm enabling it for now: it just provides tab completion for roam note titles.
#+name: org-roam-completion-everywhere
#+begin_src elisp :tangle no
(org-roam-completion-everywhere t)
#+end_src
** Capture templates
It takes some work to get `doct` to work with org roam... but from [[https://gist.github.com/vherrmann/f9b21eeea7d7c9123dc400a30599d50d][this gist]], we get the `doct-org-roam` function:
#+name: doct-org-roam
#+begin_src elisp :tangle no
(defun doct-org-roam-convert (groups)
  "Convert GROUPS of templates to `org-roam' compatible templates."
  (setq doct-templates
        (mapcar (lambda (template)
                  (if-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                            (org-roam-props (plist-get (plist-get props :doct) :org-roam)))
                      `(,@template ,@org-roam-props)
                    template))
                (doct-flatten-lists-in groups))))

(defun doct-org-roam--target-file (value)
  "Convert declaration's :file VALUE and extensions to capture template syntax."
  (let (type target)
    ;; TODO: This doesn't catch :olp used together with :datetree
    (when-let ((olp (doct--get :olp)))
      (push :olp type)
      (push olp target))
    (if-let ((head (doct--get :head)))
        (progn
          (push :head type)
          (push (pcase head
                  ((pred stringp) (if (doct--expansion-syntax-p head)
                                      (doct--replace-template-strings
                                       head)
                                    head))
                  ((pred functionp) (doct--fill-template (funcall head)))
                  ((pred doct--list-of-strings-p)
                   (mapconcat (lambda (element)
                                (if (doct--expansion-syntax-p element)
                                    (doct--fill-template element)
                                  element))
                              head "\n")))
                target))
      (when-let ((datetree (doct--get :datetree)))
        (push :datetree type)
        (push datetree target)))
    (push :file type)
    (push (doct--type-check :file value '(stringp doct--variable-p)) target)
    `(,(intern (mapconcat (lambda (keyword)
                            (substring (symbol-name keyword) 1))
                          (delq nil type) "+"))
      ,@(delq nil target))))

(defun doct-org-roam--target ()
  "Convert declaration's target to template target."
  (let ((doct-exclusive-target-keywords '(:file :node)))
    (pcase (doct--first-in doct-exclusive-target-keywords)
      ('nil (signal 'doct-no-target `(,doct-exclusive-target-keywords nil ,doct--current)))
      (`(:id ,id) `(id ,(doct--type-check :id id '(stringp))))
      (`(:file ,file) (doct-org-roam--target-file file)))))

(defun doct-org-roam--compose-entry (keys name parent)
  "Return a template suitable for `org-roam-capture-templates'.
The list is of the form: (KEYS NAME type target template additional-options...).
`doct--current-plist' provides the type, target template and additional options.
If PARENT is non-nil, list is of the form (KEYS NAME)."
  `(,keys ,name
          ,@(unless parent
              `(,(doct--entry-type)
                ,(doct--template)
                :target ,(doct-org-roam--target)
                ,@(doct--additional-options)))
          :doct ( :doct-name ,name
                  ,@(cdr doct--current)
                  ,@(when-let ((custom (doct--custom-properties)))
                      `(:doct-custom ,custom)))))

(defun doct-org-roam (declarations)
  "Convert DECLARATIONS to `org-roam-capture-templates'.
DECLARATIONS must be of the same form that `doct' expects with
one addition: the :org-roam keyword.
The :org-roam keyword's value must be a plist mapping `org-roam''s
template syntax extensions (e.g. :file-name :head) to their appropriate values.
Note this does validate the :org-roam plist's values or keywords."

  ;;TODO: we should preserve doct-after-conversion-functions
  ;;in case user already has other functions set.
  (let ((doct-after-conversion-functions (append '(doct-org-roam-convert)
                                                 doct-after-conversion-functions)))
    (cl-letf (((symbol-function 'doct--compose-entry) #'doct-org-roam--compose-entry))
      (doct declarations))))
#+end_src
Notably, the backtick is crucial for setting the hook in my anki template
#+name: org-roam-capture-templates
#+begin_src elisp :tangle no
(setq org-roam-completion-system 'default
      org-roam-capture-templates
      (doct-org-roam
       `(:group "Org Roam"
         :file "%<%Y%m%d%H%M%S>-${slug}.org"
         :head "#+title: ${title}\n"
         :unnarrowed t
         :function ignore ;org-roam hardcodes target file logic
         :type plain
         :children
         (("Default"
           :keys "d"
           :template "%?")
          ("Anki Card"
           :keys "a"
           :hook ,(defun set-anki-deck-from-tags ()
                    (let ((tags (completing-read-multiple "Tag: " (org-roam-tag-completions))))
                      (org-roam-tag-add tags)
                                        ; NOTE this only sets the first tag as ANKI_DECK
                      (org-set-property "ANKI_DECK" (car tags))))
           :template ("* ${title}"
                      "%?"))))))

(setq org-roam-dailies-directory "journals/"
      org-roam-dailies-capture-templates
      '(("d" "default" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "Journal/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("t" "Task" entry
         #'org-roam-capture--get-point
         "* TODO %?\n  %U\n  %a\n  %i"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Tasks")
         :empty-lines 1
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("j" "journal" entry
         #'org-roam-capture--get-point
         "* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Log")
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("l" "log entry" entry
         #'org-roam-capture--get-point
         "* %<%I:%M %p> - %?"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Log")
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
        ("m" "meeting" entry
         #'org-roam-capture--get-point
         "* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
         :file-name "Journal/%<%Y-%m-%d>"
         :olp ("Log")
         :head "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")))
#+end_src
** Dailies Protocol
#+begin_src emacs-lisp
(after! org-protocol
  (defun org-roam-protocol-open-daily (info)
    (let ((goto (plist-get info :goto))
          (keys (plist-get info :keys)))
      (org-roam-dailies-capture-today goto keys))
    nil)

  (push '("org-roam-daily"  :protocol "roam-daily"   :function org-roam-protocol-open-daily)
        org-protocol-protocol-alist))
#+end_src
* Reference [0/1]
- [ ] TODO change these to relative paths
- [ ] TODO set up ebib (the [[a][spacemacs bibtex layer]] should be helpful)
Use org-ref and bibtex for bibliographic references
#+begin_src elisp
(use-package! org-ref
  :defer t
  :config
  (setq bibtex-completion-bibliography "/Users/pakelley/.local/share/bibtex/references.bib"
        bibtex-completion-library-path "/Users/pakelley/.local/share/bibtex/pdfs/"
        bibtex-completion-notes-path "/Users/pakelley/.local/share/bibtex/notes.org")
  (setq reftex-default-bibliography '("/Users/pakelley/.local/share/bibtex/references.bib"))
  (setq org-ref-default-bibliography '("/Users/pakelley/.local/share/bibtex/references.bib")
        org-ref-pdf-directory "/Users/pakelley/.local/share/bibtex/pdfs/"
        org-ref-bibliography-notes "/Users/pakelley/.local/share/bibtex/notes.org"))
#+end_src
* Todos
** Todo keywords [0/1]
- [ ] TODO: do I need both `CANCELLED` and `TRASH`?
The sequence of stages my tasks go through. See the [[https://orgmode.org/manual/Tracking-TODO-state-changes.html][org manual]] for more info, but `!` gives a timestamp, `@` lets you leave a note when transitioning through that state, and `/` denotes whether the other symbols happen when transitioning in vs out of the state (before `/` is for transitioning into the state, which is the default).
- TODO: on the agenda, but not something to immediately work on
- NEXT: the next tag in a project (in the GTD sense)
- WAIT: blocked by something, don't even consider it a todo until it's unblocked
- DONE: finished, congrats
- CANCELLED: decided not to do this while working on it
- TRASH: decided not to do this while prioritizing

#+name: todo-keywords
#+begin_src elisp :tangle no
(setq org-todo-keywords
      '((sequence "NEXT(n)" "TODO(t!)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@!)" "TRASH(r!)")))
(setq org-todo-keyword-faces
      '(("NEXT" . (:foreground "#f0dfaf" :weight bold))
        ("WAIT" . (:foreground "#dc8cc3" :weight bold))
        ("CANCELED" . (:foreground "#8cd0d3" :weight bold))
        ("TRASH" . (:foreground "#dfaf8f" :weight bold))))
#+end_src
* Capture
** Capture Templates [0/1]
`doct` makes writing capture templates much simpler and more readable
#+begin_src elisp :noweb no-export
(use-package! doct
  :after (org org-capture)
  :commands doct
  :custom
  <<org-capture-templates>>)
  
#+end_src
Nice function for passing properties to `doct`
#+begin_src elisp :tangle no
(defun my/doct-properties ()
                   "Add declaration's :properties to current entry."
                   (let ((properties (doct-get :properties)))
                     (dolist (keyword (seq-filter #'keywordp properties))
                       (org-set-property (substring (symbol-name keyword) 1)
                                         (plist-get properties keyword)))))
;; Usage:
;; (doct '(("My capture template"
;;          ...
;;          :hook my/org-property-drawer
;;          :properties (:anki_deck "${category}"))))
#+end_src
See the [[https://orgmode.org/manual/Template-expansion.html][template expansion docs]] for more info on the syntax here
Appending to existing templates to keep project templates
- [ ] figure out where existing templates are coming from, and migrate useful ones here
#+name: org-capture-templates
#+begin_src elisp :tangle no
;; setq
(org-capture-templates
 (append org-capture-templates
         (doct '(("Inbox"
                  :keys "i"
                  :file "~/.local/share/notes/gtd/inbox.org"
                  :template "* %?"
                  :kill-buffer t)
                 ("Today"
                  :keys "2"
                  :file "~/.local/share/notes/gtd/org-gtd-tasks.org"
                  :olp ("Calendar")
                  :template ("* TODO %?"
                             "SCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))")
                  :prepare-finalize (lambda () (progn (org-priority)
                                                      (org-set-tags-command)))
                  :kill-buffer t)
                 ("Meeting"
                  :keys "m"
                  :children
                  (("Retro"
                    :keys "r"
                    :file "~/.local/share/notes/meetings/retro.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Nico 1:1"
                    :keys "n"
                    :file "~/.local/share/notes/meetings/nico.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Haotian 1:1"
                    :keys "h"
                    :file "~/.local/share/notes/meetings/haotian.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Parking Lot"
                    :keys "p"
                    :file "~/.local/share/notes/meetings/parking-lot.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)
                   ("Kinso"
                    :keys "k"
                    :file "~/.local/share/notes/meetings/kinso.org"
                    :datetree t
                    :template "* %?"
                    :kill-buffer t)))
                 ("Shopping" :keys "s"
                  :file "~/.local/share/notes/reference/shopping.org"
                  :template "* %?"
                  :children
                  (("Home" :keys "h" :olp ("Home"))
                   ("Christmas" :keys "c" :olp ("Christmas"))
                   ("Gift" :keys "g" :olp ("Gifts")) ; TODO either add recipient as tag or in olp
                   ("Groceries" :keys "o" :olp ("Groceries"))))
                 (:group "Reference"
                  :file "~/.local/share/notes/reference/capture.org"
                  :template "* %?"
                  :children
                  (("Food"
                    :keys "f"
                    :children
                    (("Recipe"     :keys "r" :olp ("Recipes"))
                     ("Cocktail"   :keys "c" :olp ("Cocktails"))
                     ("Restaurant" :keys "s" :olp ("Restaurants"))))
                   ("Media" :keys "e"
                    :children
                    (("Movie"   :keys "m" :olp ("Movies"))
                     ("Show"    :keys "s" :olp ("Shows"))
                     ("Book"    :keys "b" :olp ("Books"))
                     ("Article" :keys "a" :olp ("Articles"))
                     ("Album"   :keys "l" :olp ("Albums"))))
                   ("Repo" :keys "r" :olp ("Repos"))))))))
#+end_src
** capture everywhere
When I'm doing things outside of emacs, it would be nice to still use the same capture interface. I used to use org protocol plus an alfred command, but I opted for something that utilizes org-mode's typical capture interface, by popping up a new emacs frame and capturing from there.
Heavily inspired by [[https://macowners.club/posts/org-capture-from-everywhere-macos/][this blog post]] (for the majority of the logic) and [[https://github.com/tecosaur/emacs-everywhere][emacs-everywhere]] (borrowed the logic for getting back to the app I was in before capturing).
Similar to my setup for emacs-everywhere, I have an algfred workflow that uses a keybinding to trigger a script running `/usr/local/bin/emacsclient --eval "(capture-everywhere)"`.
#+begin_src elisp
(after! emacs-everywhere
  (defun get-app-name ()
    "Get the name of the current app (useful for returning to that app later). Currently uses osascript, so only useful on macos."
    (let ((default-directory emacs-everywhere--dir))
      (with-temp-buffer
        (call-process "osascript" nil t nil "app-name")
        (string-trim (buffer-string)))))

  (defun capture-everywhere ()
    "Create a new frame and run `org-capture'."
    (interactive)
    (require 'noflet)
    (make-frame `((name . "capture")
                  (top . 300)
                  (left . 700)
                  (width . 80)
                  (height . 25)
                  (emacs-everywhere-prior-app . ,(get-app-name))))

    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
            (org-capture)))


  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame and return to the app we came from"
    (when emacs-everywhere-window-focus-command
      (apply #'call-process (car emacs-everywhere-window-focus-command)
             nil nil nil
             (mapcar (lambda (arg)
                       (replace-regexp-in-string "%w" (frame-parameter nil 'emacs-everywhere-prior-app) arg))
                     (cdr emacs-everywhere-window-focus-command))))
    (delete-frame)))
#+end_src
* Agenda
#+begin_src emacs-lisp :noweb no-export
(use-package! org-agenda
  :commands org-agenda
  :custom
  <<agenda-files>>
  :config
  <<agenda-prefix>>
  <<sync-buffer-to-file>>
  <<sync-file-to-agenda>>
  <<agenda-reschedule>>)
#+end_src
** Agenda Files
Only track my task-related files in the agenda
#+name: agenda-files
#+begin_src elisp :tangle no
(org-agenda-files '("~/.local/share/notes/gtd/org-gtd-tasks.org"))
#+end_src
** Agenda format
Simplify the agenda prefix to only include what I need to see
#+name: agenda-prefix
#+begin_src emacs-lisp :tangle no
(setq org-agenda-prefix-format
      '((agenda . "  %?-12t")
        (todo   . " ")
        ;; should maybe come back to these next two, but haven't had a need for it yet
        (tags   . " %i %-12:c")
        (search . " %i %-12:c")))
#+end_src
** Sync
*** Save buffers when modifying todos (taken from [[https://emacs.stackexchange.com/a/33063/15634][this SO answer]])
#+name: sync-buffer-to-file
#+begin_src elisp :tangle no
(defmacro η (fnc)
  "Return function that ignores its arguments and invokes FNC."
  `(lambda (&rest _rest)
     (funcall ,fnc)))

(advice-add 'org-deadline       :after (η #'org-save-all-org-buffers))
(advice-add 'org-schedule       :after (η #'org-save-all-org-buffers))
(advice-add 'org-store-log-note :after (η #'org-save-all-org-buffers))
(advice-add 'org-todo           :after (η #'org-save-all-org-buffers))
(advice-add 'org-refile         :after (η #'org-save-all-org-buffers))
#+end_src
*** Update agenda after 5mins of idle time (inspired by [[https://emacs.stackexchange.com/a/47266/15634][this SO answer]]) [0/1]
- [ ] need to also sync file to buffer
#+name: sync-file-to-agenda
#+begin_src elisp :tangle no
(run-with-idle-timer 300 t (lambda () (save-window-excursion (org-agenda nil "."))))
#+end_src
** Change refile targets so I can refile to wherever I want from the agenda (e.g. my reference org files, and the inbox if I just want to reprocess a task completely)
#+begin_src emacs-lisp
(use-package! org-refile
  :after org-agenda
  :config
  (add-to-list 'org-refile-targets `(,(directory-files "~/.local/share/notes/reference" t ".*\\.org$") :maxlevel . 3))
  (add-to-list 'org-refile-targets `(,(directory-files "~/.local/share/notes/gtd" t ".*\\.org$") :maxlevel . 3)))
#+end_src
** Quick actions for rescheduling to today/tomorrow (used pretty commonly when things roll over)
#+name: agenda-reschedule
#+begin_src emacs-lisp :tangle no
(defun org-agenda-reschedule-to-today (&optional arg)
  "Reschedule selected task(s) for today."
  (interactive "P")
  (org-agenda-schedule arg "."))

(defun org-agenda-reschedule-to-tomorrow (&optional arg)
  "Reschedule selected task(s) for tomorrow."
  (interactive "P")
  (org-agenda-schedule arg "+1d"))

(setq org-agenda-bulk-custom-functions '((?. org-agenda-reschedule-to-today)
                                         (?> org-agenda-reschedule-to-tomorrow)))
(map! (:map org-agenda-mode-map "." #'org-agenda-reschedule-to-today)
      (:map evil-org-agenda-mode-map :m "." #'org-agenda-reschedule-to-today)
      (:map org-agenda-mode-map ">" #'org-agenda-reschedule-to-tomorrow)
      (:map evil-org-agenda-mode-map :m ">" #'org-agenda-reschedule-to-tomorrow))
#+end_src
** Quick actions for sending back to "incubate"
#+name: agenda-incubate-and-hatch
#+begin_src emacs-lisp :tangle no
(defun +patch/gen-org-refile-rfloc (file headline)
  "Format a specified file/heading for passing to org-refile and org-agenda-refile.

 FILE is the file to refile into.

 HEADLINE is the headline (inside FILE) to refile into."
  (let ((pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (list headline file nil pos)))

(defun +patch/org-agenda-refile (file headline)
  "Refile item at point to a particular place via org-agenda-refile, but
 with a simpler interface.

 FILE is the file to refile into.

 HEADLINE is the headline (inside FILE) to refile into."
  (save-window-excursion
    (org-agenda-refile nil (+patch/gen-org-refile-rfloc file headline))))

;; FIXME setting here instead of in :custom becuase it's not working in :custom (see note above)
(setq +patch/org-gtd-tasks-file (concat (file-name-as-directory org-gtd-directory) "org-gtd-tasks.org"))

(defun org-agenda-incubate (&optional arg)
  "Incubate a specified task (includes refiling to incubate section, and specifiying a date to review the task)"
  (interactive "P")
  (org-agenda-schedule arg)
  (+patch/org-agenda-refile +patch/org-gtd-tasks-file "Incubate"))

(defun org-agenda-hatch (&optional arg)
  "Un-incubate (or 'hatch') a specified task (includes refiling to calendar section, and specifiying the date to complete the task)"
  (interactive "P")
  (org-agenda-schedule arg)
  (+patch/org-agenda-refile +patch/org-gtd-tasks-file "Calendar"))

(setq org-agenda-bulk-custom-functions
      (append org-agenda-bulk-custom-functions '((?i org-agenda-incubate)
                                                 (?h org-agenda-hatch))))
(map! (:map org-agenda-mode-map "i" #'org-agenda-incubate)
      (:map org-agenda-mode-map "h" #'org-agenda-hatch)
      (:map org-agenda-keymap "h" #'org-agenda-hatch)
      (:map evil-org-agenda-mode-map "h" #'org-agenda-hatch)
      (:map evil-org-agenda-mode-map :m "i" #'org-agenda-incubate)
      (:map evil-org-agenda-mode-map :m "h" #'org-agenda-hatch))
#+end_src
** Super Agenda [0/9]
A few notes on this:
- including both "agenda" and "alltodo" lets you have both the agenda (with the time grid) /and/ the todo list
- I keep my active TODOs (i.e. the ones scheduled for today, except for "WAIT") in the agenda, and everything else in the todo list (I just want to declutter my agenda be removing anything I have to wait on, and therefore probably can't accurately predict when I can get it done)
- I use the order to split the view into 3 sections: the timeboxed agenda, the regular todo list, and the degenerate todos (unscheduled or overdue)
Future enhancements
- [ ] review the other org props I'm setting here
- [ ] filter "other tasks" after [[https://github.com/alphapapa/org-super-agenda/pull/149][this PR]] is merged (only include NEXT items for the next week or so)
- [ ] format overdue/unscheduled once [[https://github.com/alphapapa/org-ql/pull/44][org-ql formatting changes]] are merged
- [ ] sort sections once [[https://github.com/alphapapa/org-ql/issues/79][org-ql-block sorting]] is merged
#+begin_src elisp
(use-package! org-super-agenda
  :after (org-ql org-agenda)
  :commands org-super-agenda-mode
  :hook (org-agenda-mode . org-super-agenda-mode)
  :custom
  (org-agenda-include-deadlines t)
  (org-agenda-tags-column 100) ;; from testing this seems to be a good value
  (org-agenda-compact-blocks t)
  (org-agenda-custom-commands
   `(("." "What's happening"
      ((agenda "" ((org-agenda-span 'day)
                   (org-agenda-start-day "+0d")
                   (org-super-agenda-groups
                    '((:name "Today"
                       :time-grid t
                       :and (:scheduled today
                             :not (:tag ("%quick" "%easy"))
                             :not (:todo ("DONE" "CNCL" "WAIT")))
                       :order 0)
                      (:name "Remove anything else"
                       :discard (:anything t))))))
       (org-ql-block '(and (tags "%quick")
                           (ts-a :on today)
                           (not (todo "WAIT"))
                           (not (done))
                           (not (regexp ,org-ql-regexp-scheduled-with-time)))
                     ((org-ql-block-header "\n Quick")))
       (org-ql-block '(and (tags "%easy")
                           (ts-a :on today)
                           (not (todo "WAIT"))
                           (not (done))
                           (not (regexp ,org-ql-regexp-scheduled-with-time)))
                     ((org-ql-block-header "\n Easy")))
       (org-ql-block '(and (ts-a :to -1)
                           (not (todo "WAIT"))
                           (not (done))
                           (level 2))
                     ((org-ql-block-header "\n Overdue")))
       (org-ql-block '(and (not (scheduled))
                           (not (done))
                           (level 2))
                     ((org-ql-block-header "\n Unscheduled")))
       (org-ql-block '(and (todo "WAIT"))
                     ((org-ql-block-header "\n Waiting")))
       (org-ql-block '(and (todo "DONE")
                           (ts-a :on today))
                     ((org-ql-block-header "\n Completed today")))
       (org-ql-block '(and (tags ("%quick" "%easy"))
                           (ts-a :from +1 :to +3))
                     ((org-ql-block-header "\n Could pull in"))))))))
#+end_src
Use evil bindings on agenda headers created by super agenda (using best-looking solution from [[https://github.com/alphapapa/org-super-agenda/issues/50][this issue]])
- [ ] should do a proper evil-ification of this eventually
#+begin_src elisp
(after! evil-org-agenda
  (setq org-super-agenda-header-map (copy-keymap evil-org-agenda-mode-map)))
#+end_src
** Planning Agenda
Notably, this is where I'm defining what a task vs project are:
- a task is any task without children
- a project is a task under the "Projects" header that has children
#+begin_src emacs-lisp
(use-package! org-ql
  :after org-agenda
  :custom
  (org-super-agenda-date-format "%e %B %Y - %A")
  :config
  ;; have to setq instead of :custom bc we need access to org-ql vars (so we need it executed after the package is loaded, and :custom seems to be executed before the package is loaded)
  (setq
   +patch/daily-agenda-super-groups
   `((:name "Today"
      :time-grid t
      :and (:scheduled today
            :not (:tag ("%quick" "%easy"))
            :not (:todo ("DONE" "CNCL" "WAIT")))
      :order 0)
     (:name "Quick"
      :and (:tag "%quick"
            :scheduled today
            :not (:todo ("DONE" "CNCL" "WAIT"))
            :not (:regexp ,org-ql-regexp-scheduled-with-time)))
     (:name "Easy"
      :and (:tag "%easy"
            :scheduled today
            :not (:todo ("DONE" "CNCL" "WAIT"))
            :not (:regexp ,org-ql-regexp-scheduled-with-time)))
     (:name "Overdue"
      :and (:scheduled past
            :face error
            :not (:todo ("DONE" "CNCL" "WAIT"))))
     ;; TODO omiting this for now, until I decide on semantics for unscheduled project items and action list items
     ;; (:name "Unscheduled"
     ;;  :face error
     ;;  :and (:scheduled nil
     ;;        :not (:todo "DONE")))
     (:name "Waiting"
      :todo "WAIT")
     (:name "Completed Today"
      :and (:todo "DONE"
            :scheduled today))
     (:name "Could Pull In"
      :and (:tag ("%quick" "%easy")
            ;; scheduled in the next 3 days
            :scheduled future
            :scheduled (before ,(org-read-date nil nil "+4"))))
     (:name "Remove anything else"
      :discard (:anything t)))

   +patch/daily-agenda-query
   '(and (or (ts-active :on today)
             (scheduled :to +3)
             (scheduled :before today))
         (not (children))
         (not (todo "CNCL")))

   is-project '(and (ancestors "Planning") (children))
   is-task '(not (children))
   org-ql-views
   `(("Planning" :buffers-files
      ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query
      (and
       ;; only include tasks
       ,is-task
       ;; Get upcoming and unscheduled tasks
       (or (ts :from today :to +45)
           (and (not (scheduled)) (level 2)))
       ;; only get tasks that are still "todo"
       ;; (not (tags "Incubate"))
       (not (todo "WAIT" "DONE" "CNCL")))
      :sort
      (priority todo)
      :narrow nil
      :super-groups ((:name "Unscheduled"
                      :scheduled nil
                      :face error
                      :order 0)
                     (:auto-planning t))
      :title "Planning")
     ("Daily"
      :buffers-files ("~/.local/share/notes/gtd/org-gtd-tasks.org")
      :query ,+patch/daily-agenda-query
      :sort (priority todo date)
      :narrow nil
      :super-groups ,+patch/daily-agenda-super-groups
      :title "Daily")))

  (defun org-ql-action-list (action-list-name)
    (interactive (list (completing-read "Action List: " (--filter (string-match-p "^\@.*" it) (mapcar #'car org-tag-alist)))))
    (org-ql-search "~/.local/share/notes/gtd/org-gtd-tasks.org"
      `(and ,+patch/daily-agenda-query
            (tags "@anywhere" ,action-list-name))
      :title (format "%s action list" action-list-name)
      :super-groups +patch/daily-agenda-super-groups))

  (defun org-ql-refine-view (query)
    (interactive "xQuery: ")
    (let ((org-ql-view-query `(and ,query ,org-ql-view-query)))
      (org-ql-view-refresh))))
#+end_src
** Automatically collapse sections of my daily agenda I don't need often [0/1]
Also allow myself to (semi-permanently) expand sections that are useful to regularly see depending on what's in them.
#+begin_src elisp
(use-package! origami
  :after (org-agenda)
  :hook ((org-agenda-mode . origami-mode)
         (org-agenda-finalize . +patch/org-super-agenda-origami-fold-default))
  :config
  (setq +patch/agenda-auto-hide-groups '("Waiting" "Completed Today" "Could Pull In"))
  (defun +patch/org-super-agenda-origami-fold-default ()
    "Fold certain groups by default in Org Super Agenda buffer."
    (evil-goto-first-line)

    (--each +patch/agenda-auto-hide-groups
      (goto-char (point-min))
      (when (re-search-forward (rx-to-string `(seq bol " " ,it)) nil t)
        (origami-close-node (current-buffer) (point))))

    (beginning-of-buffer))

  (defun +patch/dont-show-waiting-in-agenda ()
    (interactive)
    (setq +patch/agenda-auto-hide-groups
          (cons "Waiting" +patch/agenda-auto-show-groups))
    (org-agenda-redo))

  (defun +patch/show-waiting-in-agenda ()
    (interactive)
    (setq +patch/agenda-hide-show-groups
          (remove "Waiting" +patch/agenda-auto-show-groups))
    (org-agenda-redo))

  (map!
   (:map evil-org-agenda-mode-map "TAB" #'origami-toggle-node)
   (:map evil-org-agenda-mode-map :m "<tab>" #'origami-toggle-node)
   (:map evil-org-agenda-mode-map :m "TAB" #'origami-toggle-node)
   (:map org-super-agenda-header-map :m "<tab>" #'origami-toggle-node)
   (:map org-super-agenda-header-map :m "TAB" #'origami-toggle-node)
   (:map org-super-agenda-header-map "TAB" #'origami-toggle-node)
   (:map org-agenda-keymap "TAB" #'origami-toggle-node)
   (:map org-agenda-keymap "<tab>" #'origami-toggle-node)
   (:map org-agenda-mode-map "TAB" #'origami-toggle-node)
   (:map org-agenda-mode-map "<tab>" #'origami-toggle-node)
   :map org-agenda-mode-map
   :localleader
   ("w" #'+patch/show-waiting-in-agenda)
   ("W" #'+patch/dont-show-waiting-in-agenda)))


#+end_src
* Export
** Set pandoc executeable, so it looks at the right one
#+begin_src emacs-lisp
(use-package! ox-pandoc
  :after ox
  :custom (org-pandoc-command "/opt/homebrew/bin/pandoc"))
#+end_src
* Deft
#+begin_src elisp
(use-package! deft
  :after org
  :custom
  (deft-directory "~/.local/share/notes")
  (deft-recursive t))
#+end_src
* General
** Notes directory
Top-level note directory, synced with Syncthing
#+name: notes-directory
#+begin_src elisp :tangle no
(setq org-directory "~/.local/share/notes")
#+end_src
** Render latex fragments when opening org file
#+name: latex-on-startup
#+begin_src elisp :tangle no
(setq org-startup-with-latex-preview t)
#+end_src
also make sure emacs can find mactex executeables (from [[https://stackoverflow.com/a/44914143/5054505][this SO answer]])
#+begin_src emacs-lisp
;; (setenv "PATH" (concat ":/Library/TeX/texbin/" (getenv "PATH")))
(add-to-list 'exec-path "/Library/TeX/texbin/")
#+end_src
and resolve weird "dvi wasn't produced please adjust 'dvipng' part of 'org-preview-latex-process-alist'" error (from [[https://stackoverflow.com/questions/3517165/pdflatex-command-not-working-in-emacs-terminal-mode][this SO post]])
#+begin_src emacs-lisp
(defun set-exec-path-from-shell-PATH ()
  (let ((path-from-shell
         (replace-regexp-in-string "[[:space:]\n]*$" ""
           (shell-command-to-string "$SHELL -l -c 'echo $PATH'"))))
    (setenv "PATH" path-from-shell)
    (setq exec-path (split-string path-from-shell path-separator))))
(when (equal system-type 'darwin) (set-exec-path-from-shell-PATH))
#+end_src
** Word wrap
Commenting this out for now; doom seems to do a good job of this on its own
#+begin_src elisp
;(setq org-startup-truncated nil)
;(setq org-startup-indented t)
#+end_src
** Refile
Commenting this out for now, unless I decide I need it
#+begin_src elisp
;(setq org-refile-targets
;      '((nil :maxlevel . 3)
;        (org-agenda-files :maxlevel . 3)))
#+end_src
* Babel [0/1]
- [ ] TODO revisit these
  #+begin_src emacs-lisp :noweb no-export
(after! org
  <<babel-evaluate>>
  <<babel-inline-images>>)
#+end_src
** Confirm evaluate
Don't prompt me to confirm every time I want to evaluate a block
#+name: babel-evaluate
#+begin_src elisp :tangle no
(setq org-confirm-babel-evaluate nil)
#+end_src
** Inline images
Display/udate images in the buffer after I evaluate a block
#+name: babel-inline-images
#+begin_src elisp :tangle no
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src
** Mermaid
Use [[https://mermaid-js.github.io/mermaid/#/][mermaid.js]] to generate diagrams in org files (rendered by babel)
Notably, you'll need to install [[https://github.com/mermaid-js/mermaid-cli][mermaid-cli]].
#+begin_src elisp
(use-package! ob-mermaid
  :defer t
  :config
  (setq ob-mermaid-cli-path "/usr/local/bin/mmdc"))
#+end_src
* Pomodoro [0/1]
- [ ] need to see if I can set slack status in pomodoro hooks
#+begin_src elisp :noweb no-export
(use-package! org-pomodoro
  :after org-agenda
  :custom
  ; my personal pomodoro lengths
  (org-pomodoro-length 40)
  (org-pomodoro-short-break-length 10)
  (org-pomodoro-long-break-length 30)
  ; wait for me to start my break
  (org-pomodoro-manual-break t)
  ; only record pomodoro-approved time: overtime doesn't get clocked
  (org-pomodoro-overtime-hook '(org-clock-out))
  ; dont use annoying multiple bell after long break
  (org-pomodoro-long-break-sound org-pomodoro-short-break-sound)
  :config
  <<clockreport-format>>
  (defun +org/switch-task (&optional arg)
    (interactive "P")
    (org-agenda-clock-out)
    (org-agenda-clock-in arg))
  (map! :after org-agenda
        :leader
        (:prefix "n"
         :desc "pomodoro" "p" #'org-pomodoro)
        :map org-agenda-mode-map
        :localleader
        (:prefix ("c" . "clock")
         :desc "switch task" "w" #'+org/switch-task
         :desc "pomodoro" "p" #'org-pomodoro)))
#+end_src

This gives some useful summary info about time spent on tasks from the agenda, when you have the discipline to use org's clock features.

Oh my god, this is complicated without some background knowledge... see the [[https://orgmode.org/manual/The-clock-table.html][clocktable docs]] for info on setting this var, see [[https://orgmode.org/manual/The-Spreadsheet.html][the spreadsheet docs]] for info on the formula (the [[https://orgmode.org/manual/References.html][references docs]] are a good starting point), and just know that this is using calc under the hood with (what seems to be) org specific additions for the table references.
I have not been able to find a way to change the column names for the clockreport.
My setting here is originally based on [[https://emacs.stackexchange.com/a/12883/15634][this SE answer]].
The save-window-excursion is here bc for some reason formatting the clockreport is leaving the agenda buffer (so I have to navigate to the agenda explicitly after loading it)
  #+name: clockreport-format
  #+begin_src emacs-lisp :tangle no
(setq org-agenda-clockreport-parameter-plist
   `(:link t :maxlevel 2 :formula ,(format "$5=ceil(($3+$4)*60/%s);N" org-pomodoro-length)))
#+end_src

* Tags
Make my most frequently used tags quickly available
#+name: tag-list
#+begin_src elisp :tangle no
(setq org-tag-alist '(("@home")
                      ("@work")
                      ("@cheryls")
                      ("@parents")
                      ("@errands")
                      ("@phone")
                      ("@email")
                      ("@anywhere")
                      ("%quick")
                      ("%easy")))
#+end_src
* Codeblocks
** Keep parinfer from constantly asking if it can indent things
#+begin_src emacs-lisp
(use-package! parinfer-rust-mode
  :after parinfer
  :custom
  (parinfer-rust-check-before-enable nil))
#+end_src
** poly-org for better language support in code blocks
Not starting automatically, as I'm still running into a few issues so far.
#+begin_src emacs-lisp :tangle yes
(use-package! poly-org
  :after org)
#+end_src
* Styling
** Bullets
#+begin_src elisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t))

(after! org-fancy-priorities
  (setq org-ellipsis " ▾ "
        org-hide-leading-stars t
        org-priority-highest ?A
        org-priority-lowest ?E
        org-fancy-priorities-list
        `(,(list ?A (all-the-icons-octicon "flame" :face 'all-the-icons-red))
          ,(list ?B (all-the-icons-faicon "bolt" :face 'all-the-icons-orange))
          ,(list ?C (all-the-icons-faicon "check" :face 'all-the-icons-yellow))
          ,(list ?D (all-the-icons-faicon "beer" :face 'all-the-icons-green))
          ,(list ?E (all-the-icons-faicon "bed" :face 'all-the-icons-blue)))))




#+end_src
** org-modern
#+begin_src elisp
(use-package! org-modern
  :after org
  :hook
  (org-mode . org-modern-mode)
  ;; until I figure out how to keep org-modern from inverting face on agenda priorities, leave off org-modern-agenda
  ;;(org-agenda . org-modern-agenda)
  :custom
  (org-modern-priority nil)
  (org-modern-internal-target `(,(all-the-icons-material "redo" :face 'all-the-icons-blue) t " "))
  (org-modern-star ["◉" "○" "✸" "✿" "✤" "✜" "◆"])
  (org-modern-todo-faces
      '(("NEXT" . (:background "#f0dfaf" :foreground "black" :weight semibold))
        ("WAIT" . (:background "#dc8cc3" :foreground "black" :weight semibold))
        ("CNCL" . (:background "#8cd0d3" :foreground "black" :weight semibold))))
  (org-modern-list '((43 . "➤")
                     (45 . "–")
                     (42 . "•"))))
#+end_src
* General org config
#+begin_src emacs-lisp :noweb no-export
(use-package! org
  :commands org-mode
  :config
  <<tag-list>>
  <<latex-on-startup>>
  <<notes-directory>>
  <<todo-keywords>>)

#+end_src
